(() => { "use strict"; class t { static get CANVAS_HEIGHT() { return t.TILE_SIZE * t.CANVAS_TILE_HEIGHT } static get CANVAS_WIDTH() { return t.TILE_SIZE * t.CANVAS_TILE_WIDTH } static get ASPECT_RATIO() { return t.CANVAS_TILE_HEIGHT / t.CANVAS_TILE_WIDTH } static get UI_RENDER_LAYER() { return t.OBJECT_RENDERING_LAYERS - 1 } static get UI_COLLISION_LAYER() { return t.OBJECT_COLLISION_LAYERS - 1 } static get CANVAS_CENTER_TILE_Y() { return this.CANVAS_TILE_HEIGHT / 2 } static get CANVAS_CENTER_TILE_X() { return this.CANVAS_TILE_WIDTH / 2 } static get CANVAS_CENTER_PIXEL_X() { return t.CANVAS_WIDTH / 2 } static get CANVAS_CENTER_PIXEL_Y() { return t.CANVAS_HEIGHT / 2 } } t.CANVAS_TILE_HEIGHT = 18, t.CANVAS_TILE_WIDTH = 30, t.TILE_SIZE = 16, t.OBJECT_RENDERING_LAYERS = 16, t.OBJECT_COLLISION_LAYERS = 16, t.CONTEXT_IMAGE_SMOOTHING_ENABLED = !1; class e { static renderSprite(e, i, s, n, o, r, a, h, c = {}) { var d, l; let p = a ? a * t.TILE_SIZE : t.TILE_SIZE, g = h ? h * t.TILE_SIZE : t.TILE_SIZE, m = null !== (d = c.scale) && void 0 !== d ? d : 1, u = null !== (l = c.rotation) && void 0 !== l ? l : 0, y = c.opacity && c.opacity < 1, b = 0 !== u, v = y || b; if (v && (e.save(), y && (e.globalAlpha = Math.max(0, c.opacity)), b)) { let i = Math.floor((o + a / 2) * t.TILE_SIZE) + .5, s = Math.floor((r + h / 2) * t.TILE_SIZE) + .5; e.translate(i, s), e.rotate(u * Math.PI / 180), e.translate(-i, -s) } let I = Math.floor(p / 2), E = Math.floor(g / 2); c.centered && e.translate(-I, -E), e.drawImage(i, s * t.TILE_SIZE, n * t.TILE_SIZE, p, g, Math.floor(o * t.TILE_SIZE), Math.floor(r * t.TILE_SIZE), p * m, g * m), c.centered && e.translate(I, E), v && e.restore() } static renderSubsection(e, i, s, n, o, r) { let a = Math.floor(s * t.TILE_SIZE), h = Math.floor(n * t.TILE_SIZE), c = Math.floor(o * t.TILE_SIZE), d = Math.floor(r * t.TILE_SIZE); i.drawImage(e.canvas, a, h, c - a, d - h, 0, 0, i.canvas.width, i.canvas.height) } static renderCircle(e, i, s, n = {}) { e.beginPath(), e.arc(i * t.TILE_SIZE + t.TILE_SIZE / 2, s * t.TILE_SIZE + t.TILE_SIZE / 2, t.TILE_SIZE / 2, 0, 2 * Math.PI), e.stroke(), e.fillStyle = n.colour || "saddlebrown", e.fill() } static fillRectangle(e, i, s, n, o, r = {}) { e.strokeStyle = r.colour ? r.colour : "black", e.fillStyle = r.colour ? r.colour : "black", e.beginPath(), e.rect(Math.floor(i * t.TILE_SIZE), Math.floor(s * t.TILE_SIZE), n, o), e.stroke(), e.fill() } static strokeRectangle(t, e, i, s, n, o) { t.strokeStyle = o || "black", t.lineWidth = 1, t.strokeRect(e + .5, i + .5, s - 1, n - 1) } static clearCanvas(t) { t.clearRect(0, 0, t.canvas.width, t.canvas.height) } static createCanvas(e, i) { const s = document.createElement("canvas"); return s.width = e ? e * t.TILE_SIZE : t.CANVAS_WIDTH, s.height = i ? i * t.TILE_SIZE : t.CANVAS_HEIGHT, s } static getContext(e) { let i = e.getContext("2d"); return i.imageSmoothingEnabled = t.CONTEXT_IMAGE_SMOOTHING_ENABLED, i } static positionToPixelPosition(e) { return e * t.TILE_SIZE } static renderText(e, i, s, n, o = {}) { let r = o.size ? o.size : 16, a = o.colour ? o.colour : "black"; e.font = `${r}px Helvetica`, e.fillStyle = `${a}`, e.fillText(i, s * t.TILE_SIZE, n * t.TILE_SIZE) } static textToArray(t, e, i = {}) { var s, n; let o = null !== (s = i.size) && void 0 !== s ? s : 16, r = null !== (n = i.colour) && void 0 !== n ? n : "black", a = document.createElement("canvas").getContext("2d"); a.font = `${o}px Helvetica`, a.fillStyle = `${r}`; let h = t.split(" "), c = "", d = []; for (let t = 0; t < h.length; t++) { let i = `${c} ${h[t]}`; a.measureText(i).width >= e ? (d.push(i), c = "") : h.length - 1 !== t ? c = i.trim() : d.push(i) } return d } } class i { constructor(i, s, n, o, r, a) { this.container = i, this.engineObjectList = o, this.engineObjectDetails = r, this.engineControls = a, this.CANVAS_HEIGHT = t.CANVAS_HEIGHT, this.CANVAS_WIDTH = t.CANVAS_WIDTH, this.delta = 0, this.lastRenderTimestamp = 0, this.assets = { images: {}, audio: {} }, this.debug = { enabled: !0, stats: { fps: !1, fpsCounter: 0, objectCount: !1 }, breakpoint: { frame: !1 }, timing: { frame: !1, frameBackground: !1, frameUpdate: !1, frameRender: !1, frameDestroy: !1 }, ui: { grid: { lines: !1, numbers: !1 }, canvasLayers: !1 }, object: { renderBoundary: !1, renderBackground: !1 } }, this.gamepad = void 0, this.engineTimer = 0, this.scenes = [...s], Object.keys(n.images).forEach((t => { this.assets.images[t] = new Image, this.assets.images[t].src = n.images[t] })), Object.keys(n.audio).forEach((t => { this.assets.audio[t] = new Audio(n.audio[t]) })), this.debug.enabled && this.initialiseDebuggerListeners(), this.canvas = this.createCanvas(), this.context = e.getContext(this.canvas), i.append(this.canvas), document.addEventListener("visibilitychange", (t => { "visible" === document.visibilityState ? console.log("tab is active") : console.log("tab is inactive") })), this.intialiseGamepadListeners(), this.changeScene(this.scenes[0]), this.frame(0) } createCanvas() { const t = e.createCanvas(); return t.addEventListener("contextmenu", (t => { t.preventDefault() })), t } changeScene(t) { this.currentScene = Reflect.construct(t, [this]) } frame(t) { this.debug.breakpoint.frame, this.debug.timing.frame && console.log(`[frame] ${this.delta}`), this.setDelta(t), e.clearCanvas(this.context), this.currentScene.frame(this.delta), this.debug.stats.fps && (this.debug.stats.fpsCounter && this.renderStats(0, "FPS", `${Math.round(1e3 / (performance.now() - this.debug.stats.fpsCounter))} FPS`), this.debug.stats.fpsCounter = t), this.debug.stats.objectCount && this.renderStats(1, "Objects", `${this.currentScene.objects.length} objects`), this.renderGrid(), this.currentScene.flaggedForMapChange && this.currentScene.changeMap(this.currentScene.flaggedForMapChange), this.engineTimer += this.delta, this.engineTimer > 1 && (this.engine(), this.engineTimer = 0), window.requestAnimationFrame(this.frame.bind(this)) } setDelta(t) { this.delta = (t - this.lastRenderTimestamp) / 1e3, this.lastRenderTimestamp = t } renderStats(e, i, s) { this.context.fillStyle = "red", this.context.font = "12px serif", this.context.fillText(s, this.CANVAS_WIDTH - 50, (e + 1) * t.TILE_SIZE) } renderGrid() { if ((this.debug.ui.grid.lines || this.debug.ui.grid.numbers) && e.fillRectangle(this.context, 0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT, { colour: "rgba(0, 0, 0, 0.25)" }), this.debug.ui.grid.lines) for (let i = 0; i < this.CANVAS_WIDTH; i += t.TILE_SIZE)for (let s = 0; s < this.CANVAS_HEIGHT; s += t.TILE_SIZE)e.strokeRectangle(this.context, i, s, t.TILE_SIZE, t.TILE_SIZE, "black"); if (this.debug.ui.grid.numbers) for (let e = 0; e < t.CANVAS_TILE_WIDTH; e++)for (let i = 0; i < t.CANVAS_TILE_HEIGHT; i++)this.context.fillStyle = "black", this.context.font = "8px helvetica", this.context.fillText(`${e}`, e * t.TILE_SIZE + 1, i * t.TILE_SIZE + 8), this.context.fillText(`${i}`, e * t.TILE_SIZE + 6, i * t.TILE_SIZE + 14) } initialiseDebuggerListeners() { void 0 !== this.engineControls && (this.engineControls.gridLines && this.engineControls.gridLines.addEventListener("click", (() => { this.debug.ui.grid.lines = !this.debug.ui.grid.lines })), this.engineControls.gridNumbers && this.engineControls.gridNumbers.addEventListener("click", (() => { this.debug.ui.grid.numbers = !this.debug.ui.grid.numbers })), this.engineControls.breakpoint && this.engineControls.breakpoint.addEventListener("click", (() => { this.debug.breakpoint.frame = !this.debug.breakpoint.frame })), this.engineControls.fps && this.engineControls.fps.addEventListener("click", (() => { this.debug.stats.fps = !this.debug.stats.fps })), this.engineControls.objectCount && this.engineControls.objectCount.addEventListener("click", (() => { this.debug.stats.objectCount = !this.debug.stats.objectCount })), this.engineControls.timingFrame && this.engineControls.timingFrame.addEventListener("click", (() => { this.debug.timing.frame = !this.debug.timing.frame })), this.engineControls.timingFrameBackground && this.engineControls.timingFrameBackground.addEventListener("click", (() => { this.debug.timing.frameBackground = !this.debug.timing.frameBackground })), this.engineControls.timingFrameRender && this.engineControls.timingFrameRender.addEventListener("click", (() => { this.debug.timing.frameRender = !this.debug.timing.frameRender })), this.engineControls.timingFrameUpdate && this.engineControls.timingFrameUpdate.addEventListener("click", (() => { this.debug.timing.frameUpdate = !this.debug.timing.frameUpdate })), this.engineControls.canvasLayers && this.engineControls.canvasLayers.addEventListener("click", (() => { this.debug.ui.canvasLayers = !this.debug.ui.canvasLayers })), this.engineControls.renderBoundary && this.engineControls.renderBoundary.addEventListener("click", (() => { this.debug.object.renderBoundary = !this.debug.object.renderBoundary })), this.engineControls.renderBackground && this.engineControls.renderBackground.addEventListener("click", (() => { this.debug.object.renderBackground = !this.debug.object.renderBackground })), this.engineControls.fullscreen && this.engineControls.fullscreen.addEventListener("click", (() => { this.canvas.requestFullscreen().catch((t => { throw new Error(t) })) }))) } intialiseGamepadListeners() { window.addEventListener("gamepadconnected", (t => { console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.", t.gamepad.index, t.gamepad.id, t.gamepad.buttons.length, t.gamepad.axes.length), this.gamepad = t.gamepad })), window.addEventListener("gamepaddisconnected", (t => { this.gamepad = void 0 })) } engine() { if (null === this.engineObjectList) return; let t = document.createElement("ul"); this.engineObjectList.innerHTML = "", this.engineObjectList.appendChild(t), this.currentScene.objects.forEach((e => { let i = document.createElement("li"); i.innerHTML = e.constructor.name, t.appendChild(i), i.addEventListener("click", (() => { this.engineSelectedObjectId = e.id, this.updateEngineObjectDetails() })) })) } updateEngineObjectDetails() { if (void 0 === this.engineSelectedObjectId) return; if (null === this.engineObjectDetails) return; let t = this.currentScene.objects.find((t => t.id === this.engineSelectedObjectId)); void 0 !== t && (this.engineObjectDetails.innerHTML = "", this.engineObjectDetails.innerHTML += `<h3>${t.constructor.name}</h3>`, Object.keys(t).forEach((e => { let i = ""; i += '<div style="display:flex; padding: 0.25rem 0;">', i += `<span style="margin-right: auto;">${e}</span>`, i += `<input value="${t[e]}"`, i += "</div>", this.engineObjectDetails.innerHTML += i }))) } } class s { static get engineObjectList() { return document.getElementById("object-list") || null } static get engineObjectDetails() { return document.getElementById("object-details") || null } static get engineControls() { return { gridLines: document.getElementById("btnGridLines"), gridNumbers: document.getElementById("btnGridNumbers"), breakpoint: document.getElementById("btnBreakpoint"), fps: document.getElementById("btnFps"), objectCount: document.getElementById("btnObjectCount"), timingFrame: document.getElementById("btnTimingFrame"), timingFrameBackground: document.getElementById("btnTimingFrameBackground"), timingFrameRender: document.getElementById("btnTimingFrameRender"), timingFrameUpdate: document.getElementById("btnTimingFrameUpdate"), canvasLayers: document.getElementById("btnCanvasLayers"), fullscreen: document.getElementById("btnFullscreen"), renderBoundary: document.getElementById("btnRenderBoundary"), renderBackground: document.getElementById("btnRenderBackground") } } static initHelpers() { window.o = t => window.engine.currentScene.objects.find((e => e.id === t)) } } class n { constructor(t) { this.scene = t, this.globals = {}, this.context = this.scene.context, this.assets = this.scene.assets } destroy() { } } class o { static getMousePosition(e, i) { let s, n = e.getBoundingClientRect(), o = { height: n.height, width: n.width }, r = { clientX: i.clientX, clientY: i.clientY }; if (e.width > e.height) { s = e.width / n.width, o.height = e.height / s; let t = n.height - o.height; r.clientY -= t / 2 } else { s = e.height / n.height, o.width = e.width / s; let t = n.width - o.width; r.clientX -= t / 2 } let a = e.width / o.width, h = e.height / o.height, c = (r.clientX - n.left) * a / t.TILE_SIZE, d = (r.clientY - n.top) * h / t.TILE_SIZE; return { x: Math.floor(c), y: Math.floor(d), exactX: c, exactY: d } } static setCursor(t, e) { t.style.cursor = `url("${e}"), auto` } static get isFullscreen() { return null !== document.fullscreenElement } static isClickWithin(t, e, i, s, n) { return t.exactX >= e && t.exactX <= e + s && t.exactY >= i && t.exactY <= i + n } static wasClicked(t, e) { return !!e.globals.mouse.click.left && !!this.isClickWithin(e.globals.mouse.position, t.boundingBox.left, t.boundingBox.top, t.width, t.height) } } const r = { tileset: "tileset_water", animationFrameDuration: 1, animationFrames: [{ spriteX: 0, spriteY: 0 }, { spriteX: 1, spriteY: 0 }, { spriteX: 2, spriteY: 0 }, { spriteX: 3, spriteY: 0 }], animationMap: [.25, .5, .75, 1] }, a = [r, r, r, r, r, r, r, r, r, r, r, r, r, r, r, r, r, r], h = { index: 0, tiles: [a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a] }; class c { get boundingBox() { let t = this.width / 2, e = this.height / 2; return { top: this.transform.position.y - e, right: this.transform.position.x + t, bottom: this.transform.position.y + e, left: this.transform.position.x - t } } constructor(t, e) { var i, s, n, o, r, a; this.scene = t, this.id = crypto.randomUUID(), this.transform.position.x = -1, this.transform.position.y = -1, this.targetX = -1, this.targetY = -1, this.width = 1, this.height = 1, this.keyListeners = {}, this.eventListeners = {}, this.flaggedForRender = !0, this.flaggedForUpdate = !0, this.flaggedForDestroy = !1, this.mainContext = this.scene.context, this.assets = this.scene.assets, void 0 !== e.positionX && (this.transform.position.x = e.positionX, void 0 === e.targetX && (this.targetX = this.transform.position.x)), void 0 !== e.positionY && (this.transform.position.y = e.positionY, void 0 === e.targetY && (this.targetY = this.transform.position.y)), void 0 !== e.targetX && (this.targetX = e.targetX), void 0 !== e.targetY && (this.targetY = e.targetY), void 0 !== e.width && (this.width = e.width), void 0 !== e.height && (this.height = e.height), this.isRenderable = null !== (i = e.isRenderable) && void 0 !== i && i, this.renderLayer = null !== (s = e.renderLayer) && void 0 !== s ? s : 0, this.renderOpacity = null !== (n = e.renderOpacity) && void 0 !== n ? n : 1, this.hasCollision = null !== (o = e.hasCollision) && void 0 !== o && o, this.collisionLayer = null !== (r = e.collisionLayer) && void 0 !== r ? r : 0, this.renderScale = null !== (a = e.renderScale) && void 0 !== a ? a : 1 } debuggerRenderBoundary(i) { e.strokeRectangle(i, Math.floor(this.boundingBox.left * t.TILE_SIZE), Math.floor(this.boundingBox.top * t.TILE_SIZE), Math.floor(this.width * t.TILE_SIZE), Math.floor(this.height * t.TILE_SIZE), "red") } debuggerRenderBackground(i) { e.fillRectangle(i, this.boundingBox.left, this.boundingBox.top, Math.floor(this.width * t.TILE_SIZE), Math.floor(this.height * t.TILE_SIZE), { colour: "red" }) } get cameraRelativePositionX() { return this.transform.position.x + this.scene.globals.camera.startX } get cameraRelativePositionY() { return this.transform.position.y + this.scene.globals.camera.startY } get pixelWidth() { return this.width * t.TILE_SIZE } get pixelHeight() { return this.height * t.TILE_SIZE } isCollidingWith(t) { return this.isWithinHorizontalBounds(t) && this.isWithinVerticalBounds(t) } isWithinHorizontalBounds(t) { return t.boundingBox.left >= this.boundingBox.left && t.boundingBox.left <= this.boundingBox.right || t.boundingBox.right >= this.boundingBox.left && t.boundingBox.right <= this.boundingBox.right } isWithinVerticalBounds(t) { return t.boundingBox.top >= this.boundingBox.top && t.boundingBox.top <= this.boundingBox.bottom || t.boundingBox.bottom >= this.boundingBox.top && t.boundingBox.bottom <= this.boundingBox.bottom } } class d { static randomIntFromRange(t, e) { return Math.floor(this.randomNumberFromRange(t, e)) } static randomNumberFromRange(t, e) { return Math.random() * (e - t + 1) + t } static randomStartingDelta(t) { return Math.random() * (null != t ? t : 1) } } class l { constructor(t, e, i, s) { this.transform.position.x = t, this.transform.position.y = e, this.targetX = i, this.targetY = s } } class p { static moveTowardsPosition(t, e) { return t.targetX > t.positionX ? (t.positionX += e, t.targetX < t.positionX && (t.positionX = t.targetX)) : t.targetX < t.positionX ? (t.positionX -= e, t.targetX > t.positionX && (t.positionX = t.targetX)) : t.targetY > t.positionY ? (t.positionY += e, t.targetY < t.positionY && (t.positionY = t.targetY)) : t.targetY < t.positionY && (t.positionY -= e, t.targetY > t.positionY && (t.positionY = t.targetY)), new l(t.positionX, t.positionY, t.targetX, t.targetY) } static moveTowardsOtherEntity(t, e) { return e.positionX > t.positionX ? t.targetX += 1 : e.positionX < t.positionX ? t.targetX -= 1 : e.positionY > t.positionY ? t.targetY += 1 : e.positionY < t.positionY && (t.targetY -= 1), new l(t.positionX, t.positionY, t.targetX, t.targetY) } static moveInRandomDirection(t) { switch (d.randomIntFromRange(1, 4)) { case 1: t.targetX += 1; break; case 2: t.targetX -= 1; break; case 3: t.targetY += 1; break; case 4: t.targetY -= 1 }return new l(t.positionX, t.positionY, t.targetX, t.targetY) } static frameVelocity(t, e) { return t * e } } class g extends c { constructor(t, e) { var i, s; super(t, e), this.scene = t, this.isRenderable = !0, this.width = 1, this.height = 1, this.movementSpeed = .5, void 0 !== e.isRenderable && (this.isRenderable = e.isRenderable), this.tileset = e.tileset, this.spriteX = e.spriteX, this.spriteY = e.spriteY, this.spriteHeight = e.spriteHeight, this.spriteWidth = e.spriteWidth, this.destroyAtTarget = null !== (i = e.destroyAtTarget) && void 0 !== i && i, this.movementSpeed = null !== (s = e.movementSpeed) && void 0 !== s ? s : .5 } update(t) { this.updatePosition(t) } updatePosition(t) { if (this.transform.position.x === this.targetX && this.transform.position.y === this.targetY) return void (this.destroyAtTarget && this.scene.removeObjectById(this.id)); let e = new l(this.transform.position.x, this.transform.position.y, this.targetX, this.targetY), i = this.movementSpeed * t, s = p.moveTowardsPosition(e, i); this.transform.position.x = s.positionX, this.transform.position.y = s.positionY } render(t) { e.renderSprite(t, this.assets.images[this.tileset], this.spriteX, this.spriteY, this.transform.position.x, this.transform.position.y, this.spriteWidth, this.spriteWidth) } } class m extends c { constructor(t, e) { super(t, e), this.scene = t, this.newItemTimer = 0 } update(t) { this.updateGenerateNewItem(t) } updateGenerateNewItem(e) { if (this.newItemTimer += e, this.newItemTimer < 3) return; if (this.scene.objects.length > 15) return; let i = d.randomIntFromRange(0, this.scene.map.height); this.scene.addObject(new g(this.scene, { positionX: t.CANVAS_TILE_WIDTH, positionY: i, targetX: -1, targetY: i, tileset: "tileset_egg", spriteX: 1, spriteY: 0, destroyAtTarget: !0 })), this.newItemTimer = 0 } } class u extends c { constructor(t, e) { super(t, e), this.scene = t, this.isRenderable = !0, this.hasCollision = !0, this.renderLayer = 7, this.width = 1, this.height = 1, this.animations = { idle: [{ x: 0, y: 0 }, { x: 1, y: 0 }] }, this.animationTimer = 0, this.animationIndex = 0, this.hatchTimer = 0, this.hatchTimerMax = 7 } update(t) { this.updateAnimation(t), this.updateHatch(t) } render(t) { e.renderSprite(t, this.assets.images.tileset_egg, this.animations.idle[this.animationIndex].x, this.animations.idle[this.animationIndex].y, this.transform.position.x, this.transform.position.y) } destroy() { } updateAnimation(t) { this.animationTimer = (this.animationTimer + t) % 1, this.animationIndex = 0 } updateHatch(t) { if (this.hatchTimer += t, this.hatchTimer < this.hatchTimerMax) return; let e = this.scene.getObjectsByType(O)[0], i = new I(this.scene, { positionX: this.transform.position.x, positionY: this.transform.position.y, follows: e }); this.scene.removeObjectById(this.id), this.scene.addObject(i) } interact() { console.log("[EggObject#interact] TODO: pick up egg") } } const y = "tileset_dialogue_box", b = () => { }; class v extends c { constructor(e, i) { var s, n, o, r, a; super(e, i), this.scene = e, this.isRenderable = !0, this.height = 3, this.width = t.CANVAS_TILE_WIDTH, this.renderLayer = t.UI_RENDER_LAYER, this.textboxWidth = t.CANVAS_TILE_WIDTH - 8, this.textboxBorder = 2, this.textSize = 10, this.textSegments = [], this.textIndex = 0, this.characterIndex = 0, this.animations = { idle: [{ x: 0, y: 0 }, { x: 1, y: 0 }] }, this.animationTimer = 0, this.animationIndex = 0, this.completionTimer = 0, this.controls = { confirm: !1 }, void 0 === i.positionX && (this.transform.position.x = 0), void 0 === i.positionY && (this.transform.position.y = t.CANVAS_TILE_HEIGHT - this.height), this.showOverlay = null === (s = i.showOverlay) || void 0 === s || s, this.text = null !== (n = i.text) && void 0 !== n ? n : "...", this.onComplete = null !== (o = i.onComplete) && void 0 !== o ? o : b, this.portrait = i.portrait, this.name = i.name, this.completionDuration = i.completionDuration, this.scrollText = null === (r = i.scrollText) || void 0 === r || r, this.scrollSpeed = null !== (a = i.scrollSpeed) && void 0 !== a ? a : 48, this.keyListeners.onConfirmKeyDown = this.onConfirmKeyDown.bind(this), document.addEventListener("keydown", this.keyListeners.onConfirmKeyDown), this.scene.dispatchEvent(this.scene.eventTypes.TEXTBOX_OPENED), this.initText() } initText() { this.textSegments = e.textToArray(this.text, (this.textboxWidth - 4) * t.TILE_SIZE, { size: this.textSize }) } update(t) { void 0 !== this.completionDuration ? this.updateTimer(t) : this.updateConfirm(), this.scrollText && this.updateScrollText(t), this.updatePortraitAnimation(t) } render(t) { this.showOverlay && this.renderOverlay(t), this.hasPortrait && this.renderPortrait(t), this.generateTextbox(t), this.hasNamePlate && this.renderNamePlate(t), this.renderText(t) } destroy() { document.removeEventListener("keydown", this.keyListeners.onConfirmKeyDown), this.scene.dispatchEvent(this.scene.eventTypes.TEXTBOX_CLOSED) } updateTimer(t) { this.completionTimer += t, this.completionTimer >= this.completionDuration && (this.onComplete && this.onComplete(), this.scene.removeObjectById(this.id)) } updateScrollText(t) { this.currentText.length > this.characterIndex && (this.characterIndex += this.scrollSpeed * t) } updateConfirm() { if (this.controls.confirm) { if (this.scrollText && this.currentText.length > this.characterIndex) return this.characterIndex = this.currentText.length, void (this.controls.confirm = !1); this.textIndex += 2, this.characterIndex = 0, this.textSegments.length <= this.textIndex && (this.onComplete && this.onComplete(), this.scene.removeObjectById(this.id)), this.controls.confirm = !1 } } renderOverlay(i) { e.fillRectangle(i, 0, 0, t.CANVAS_WIDTH, t.CANVAS_HEIGHT, { colour: "rgba(0, 0, 0, 0.5)" }) } generateTextbox(i) { let s = this.textboxWidth, n = (t.CANVAS_TILE_WIDTH - s) / 2; e.renderSprite(i, this.assets.images[y], 0, 0, n, t.CANVAS_TILE_HEIGHT - 4), e.renderSprite(i, this.assets.images[y], 0, 1, n, t.CANVAS_TILE_HEIGHT - 3), e.renderSprite(i, this.assets.images[y], 0, 1, n, t.CANVAS_TILE_HEIGHT - 2), e.renderSprite(i, this.assets.images[y], 0, 2, n, t.CANVAS_TILE_HEIGHT - 1); for (let o = 1; o < s - 1; o++)e.renderSprite(i, this.assets.images[y], 1, 0, n + o, t.CANVAS_TILE_HEIGHT - 4), e.renderSprite(i, this.assets.images[y], 1, 1, n + o, t.CANVAS_TILE_HEIGHT - 3), e.renderSprite(i, this.assets.images[y], 1, 1, n + o, t.CANVAS_TILE_HEIGHT - 2), e.renderSprite(i, this.assets.images[y], 1, 2, n + o, t.CANVAS_TILE_HEIGHT - 1); e.renderSprite(i, this.assets.images[y], 2, 0, n + s - 1, t.CANVAS_TILE_HEIGHT - 4), e.renderSprite(i, this.assets.images[y], 2, 1, n + s - 1, t.CANVAS_TILE_HEIGHT - 3), e.renderSprite(i, this.assets.images[y], 2, 1, n + s - 1, t.CANVAS_TILE_HEIGHT - 2), e.renderSprite(i, this.assets.images[y], 2, 2, n + s - 1, t.CANVAS_TILE_HEIGHT - 1) } renderText(i) { if (this.textLine1) { let s = this.scrollText ? this.textLine1.substring(0, this.characterIndex) : this.textLine1; e.renderText(i, s, (t.CANVAS_TILE_WIDTH - this.textboxWidth) / 2 + 1.25, t.CANVAS_TILE_HEIGHT - 2 - .25, { size: this.textSize }) } if (this.textLine2) { let s = this.scrollText ? this.textLine2.substring(0, this.characterIndex - this.textLine1.length) : this.textLine2; e.renderText(i, s, (t.CANVAS_TILE_WIDTH - this.textboxWidth) / 2 + 1.25, t.CANVAS_TILE_HEIGHT - 1 - .25, { size: this.textSize }) } } renderPortrait(t) { e.renderSprite(t, this.assets.images.tileset_chicken, this.animations.idle[this.animationIndex].x, this.animations.idle[this.animationIndex].y, 3, 9, void 0, void 0, { scale: 8 }) } renderNamePlate(i) { e.fillRectangle(i, (t.CANVAS_TILE_WIDTH - this.textboxWidth) / 2 + 1, t.CANVAS_TILE_HEIGHT - 4, 6 * t.TILE_SIZE, 1 * t.TILE_SIZE, { colour: "#e8cfa6" }), e.renderText(i, this.name, (t.CANVAS_TILE_WIDTH - this.textboxWidth) / 2 + 1.25, t.CANVAS_TILE_HEIGHT - 3 - .25, { size: this.textSize }) } updatePortraitAnimation(t) { this.animationTimer = (this.animationTimer + t) % 4, this.animationTimer < 3.5 ? this.animationIndex = 0 : this.animationIndex = 1 } onConfirmKeyDown(t) { t.repeat || " " !== t.key.toLocaleLowerCase() || (this.controls.confirm = !0) } get hasPortrait() { return void 0 !== this.portrait } get hasNamePlate() { return void 0 !== this.name } get textLine1() { return this.textSegments[this.textIndex] } get textLine2() { return this.textSegments[this.textIndex + 1] } get currentText() { let t = ""; return this.textLine1 && (t += this.textLine1), this.textLine2 && (t += this.textLine2), t } } class I extends c { constructor(t, e) { var i, s; console.log("[ChickenObject] created"), super(t, e), this.scene = t, this.isRenderable = !0, this.hasCollision = !0, this.renderLayer = 8, this.width = 1, this.height = 1, this.animations = { idle: [{ x: 0, y: 0 }, { x: 1, y: 0 }] }, this.animationTimer = d.randomStartingDelta(4), this.animationIndex = 0, this.movementSpeed = 2, this.movementTimer = d.randomStartingDelta(2), this.movementDelay = 2, this.eggTimer = d.randomStartingDelta(2), this.eggTimerMax = 7, this.eggMax = 200, this.isMovingThisFrame = !1, this.isEdgyTeen = !1, this.canLayEggs = null !== (i = e.canLayEggs) && void 0 !== i && i, this.isEdgyTeen = 3 === d.randomIntFromRange(0, 3), this.canMove = null !== (s = e.canMove) && void 0 !== s && s, this.following = e.follows } update(t) { this.isMovingThisFrame = !1, this.updateMovement(t), this.updateAnimation(t), this.updateEgg(t) } render(t) { e.renderSprite(t, this.assets.images.tileset_chicken, this.animations.idle[this.animationIndex].x, this.animations.idle[this.animationIndex].y, this.transform.position.x, this.transform.position.y) } destroy() { console.log("[ChickenObject] destroyed") } updateAnimation(t) { this.animationTimer = (this.animationTimer + t) % 4, this.animationTimer < 3.5 ? this.animationIndex = 0 : this.animationIndex = 1 } updateMovement(t) { this.canMove && (this.movementTimer += t, this.movementTimer > this.movementDelay && this.determineNextMovement(t), this.processMovement(t)) } determineNextMovement(t) { let e; this.movementTimer = 0, e = this.following ? p.moveTowardsOtherEntity(new l(this.transform.position.x, this.transform.position.y, this.targetX, this.targetY), new l(this.following.positionX, this.following.positionY, this.following.targetX, this.following.targetY)) : p.moveInRandomDirection(new l(this.transform.position.x, this.transform.position.y, this.targetX, this.targetY)), this.scene.hasCollisionAtPosition(e.targetX, e.targetY, this) || this.scene.willHaveCollisionAtPosition(e.targetX, e.targetY, this) || this.scene.isOutOfBounds(e.targetX, e.targetY) || (this.targetX = e.targetX, this.targetY = e.targetY) } processMovement(t) { if (this.targetX !== this.transform.position.x || this.targetY !== this.transform.position.y) { let e = new l(this.transform.position.x, this.transform.position.y, this.targetX, this.targetY), i = p.moveTowardsPosition(e, p.frameVelocity(this.movementSpeed, t)); this.transform.position.x = i.positionX, this.transform.position.y = i.positionY, this.isMovingThisFrame = !0 } } updateEgg(t) { if (!this.canLayEggs) return; if (this.eggTimer += t, this.eggTimer < this.eggTimerMax) return; if (!this.isMovingThisFrame) return; let e; this.scene.getObjectsByType(I).length + this.scene.getObjectsByType(u).length > this.eggMax || (e = this.transform.position.x > this.targetX || this.transform.position.y > this.targetY ? Math.ceil : Math.floor, this.scene.addObject(new u(this.scene, { positionX: e(this.transform.position.x), positionY: e(this.transform.position.y) })), this.eggTimer = 0) } interact() { console.log("[ChickenObject#interact] TODO: pick up chicken"); let t = new v(this.scene, { text: this.isEdgyTeen ? "GET OUT OF MY ROOM MOM! GODDDD!!!!" : "bock bock... can i help you? ... cluck cluck ...", portrait: "Chicken", name: "Chicken" }); this.scene.addObject(t) } } class E extends c { constructor(t, e) { super(t, e), this.scene = t, this.hasCollision = !1, this.isRenderable = !0, this.renderLayer = 7, this.spriteX = 0, this.spriteY = 0 } render(t) { e.renderSprite(t, this.scene.assets.images.tileset_plants, this.spriteX, this.spriteY, this.transform.position.x, this.transform.position.y) } } class T extends E { constructor(t, e) { super(t, e), this.scene = t, this.spriteX = 0, this.spriteY = 1 } } class x extends E { constructor(t, e) { super(t, e), this.scene = t, this.spriteX = 0, this.spriteY = 0 } } var L; !function (t) { t.Chicken = "Chicken", t.Egg = "Egg", t.WheatSeeds = "WheatSeeds", t.TomatoSeeds = "TomatoSeeds" }(L || (L = {})); const w = { x: 3, y: 3 }, C = { x: .5, y: 3 }, _ = { x: 1, y: 3 }, S = { x: 1.5, y: 3 }, Y = [L.TomatoSeeds, L.WheatSeeds]; class X extends c { constructor(t, e) { super(t, e), this.scene = t, this.hasCollision = !1, this.isRenderable = !0, this.renderLayer = 6, this.spriteX = w.x, this.spriteY = w.y, this.counterDry = 0, this.counterGrow = 0, this.counterSpoil = 0, this.currentlyGrowing = void 0, this.isFullyGrown = !1, this.isSpoiled = !1, this.scene.addEventListener(this.scene.eventTypes.DIRT_PLACED, this.onDirtPlaced.bind(this)), this.scene.addEventListener(this.scene.eventTypes.DIRT_REMOVED, this.onDirtPlaced.bind(this)) } onDirtPlaced(t) { let e, i = this.scene.getAllObjectsAtPosition(this.transform.position.x - 1, this.transform.position.y), s = this.scene.getAllObjectsAtPosition(this.transform.position.x + 1, this.transform.position.y), n = i.filter((t => t instanceof X)).length > 0, o = s.filter((t => t instanceof X)).length > 0; e = n && o ? _ : n && !o ? S : !n && o ? C : w, this.spriteX = e.x, this.spriteY = e.y } interact() { this.isEmpty ? this.plant() : this.harvest() } plant() { let t = this.scene.selectedInventoryItem; void 0 !== t ? Y.includes(t.type) ? (console.log(`planting ${t.type}`), this.currentlyGrowing = t.type, this.hasCollision = !0, this.scene.removeFromInventory(this.scene.globals.hotbar_selected_index)) : console.log("item cannot be planted") : console.log("no item selected") } harvest() { return this.isFullyGrown ? this.isSpoiled ? (console.log(`harvesting spoiled ${this.currentlyGrowing}`), void this.scene.removeObjectById(this.id)) : (console.log(`harvesting fully grown ${this.currentlyGrowing}`), void this.scene.removeObjectById(this.id)) : (console.log(`harvesting growing ${this.currentlyGrowing}`), void this.scene.removeObjectById(this.id)) } get isEmpty() { return void 0 === this.currentlyGrowing } update(t) { this.isEmpty ? this.counterDry += t : this.isFullyGrown ? this.counterSpoil += t : this.counterGrow += t, this.isEmpty && this.counterDry > 15 ? this.scene.removeObjectById(this.id) : !this.isFullyGrown && this.counterGrow > 5 ? this.isFullyGrown = !0 : this.isFullyGrown && this.counterSpoil > 15 && (this.isSpoiled = !0) } render(t) { this.renderSprite(t) } destroy() { this.scene.dispatchEvent(this.scene.eventTypes.DIRT_REMOVED) } renderSprite(t) { this.isEmpty ? e.renderSprite(t, this.scene.assets.images.tileset_dirt, this.spriteX, this.spriteY, this.transform.position.x, this.transform.position.y, 1, 1) : this.isFullyGrown ? this.isSpoiled ? e.renderCircle(t, this.transform.position.x, this.transform.position.y, { colour: "brown" }) : e.renderCircle(t, this.transform.position.x, this.transform.position.y, { colour: "green" }) : e.renderCircle(t, this.transform.position.x, this.transform.position.y, { colour: "lightgreen" }) } } var f; !function (t) { t.UP = "w", t.DOWN = "s", t.LEFT = "a", t.RIGHT = "d" }(f || (f = {})); class O extends c { constructor(t, e) { super(t, e), this.scene = t, this.isRenderable = !0, this.hasCollision = !0, this.renderLayer = 10, this.width = 1, this.height = 1, this.movementSpeed = 4, this.controls = { [f.RIGHT]: !1, [f.LEFT]: !1, [f.UP]: !1, [f.DOWN]: !1, interact: !1, hotbar_left: !1, hotbar_right: !1, toggle_inventory: !1, dig: !1, click: !1 }, this.animations = { [f.RIGHT]: [{ x: 7, y: 10 }, { x: 10, y: 10 }], [f.LEFT]: [{ x: 7, y: 7 }, { x: 10, y: 7 }], [f.UP]: [{ x: 7, y: 4 }, { x: 10, y: 4 }], [f.DOWN]: [{ x: 7, y: 1 }, { x: 10, y: 1 }] }, this.animationsIdle = { [f.RIGHT]: [{ x: 1, y: 10 }, { x: 4, y: 10 }], [f.LEFT]: [{ x: 1, y: 7 }, { x: 4, y: 7 }], [f.UP]: [{ x: 1, y: 4 }, { x: 4, y: 4 }], [f.DOWN]: [{ x: 1, y: 1 }, { x: 4, y: 1 }] }, this.direction = f.DOWN, this.directionTime = 0, this.directionTimer = 0, this.animationIndex = 0, this.isIdle = !0, this.keyListeners.onMovementKeyDown = this.onMovementKeyDown.bind(this), this.keyListeners.onMovementKeyUp = this.onMovementKeyUp.bind(this), this.keyListeners.onOtherKeyDown = this.onOtherKeyDown.bind(this), this.keyListeners.onOtherKeyUp = this.onOtherKeyUp.bind(this), this.keyListeners.onInventoryKeyDown = this.onInventoryKeyDown.bind(this), this.keyListeners.onInventoryKeyUp = this.onInventoryKeyUp.bind(this), this.keyListeners.onInteractKeyDown = this.onInteractKeyDown.bind(this), this.keyListeners.onInteractKeyUp = this.onInteractKeyUp.bind(this), this.eventListeners.onInventoryOpened = this.onInventoryOpened.bind(this), this.eventListeners.onInventoryClosed = this.onInventoryClosed.bind(this), this.eventListeners.onChestOpened = this.onChestOpened.bind(this), this.eventListeners.onChestClosed = this.onChestClosed.bind(this), this.eventListeners.onTextBoxOpen = this.onTextBoxOpen.bind(this), this.eventListeners.onTextBoxClose = this.onTextBoxClose.bind(this), this.enableMovementKeys(), this.enableInteractKeys(), this.enableInventoryKeys(), this.enableOtherKeys(), this.enableEventListeners() } enableMovementKeys() { document.addEventListener("keydown", this.keyListeners.onMovementKeyDown), document.addEventListener("keyup", this.keyListeners.onMovementKeyUp) } disableMovementKeys() { document.removeEventListener("keydown", this.keyListeners.onMovementKeyDown), document.removeEventListener("keyup", this.keyListeners.onMovementKeyUp), this.controls[f.RIGHT] = !1, this.controls[f.LEFT] = !1, this.controls[f.UP] = !1, this.controls[f.DOWN] = !1 } enableOtherKeys() { document.addEventListener("keydown", this.keyListeners.onOtherKeyDown), document.addEventListener("keyup", this.keyListeners.onOtherKeyUp) } disableOtherKeys() { document.removeEventListener("keydown", this.keyListeners.onOtherKeyDown), document.removeEventListener("keyup", this.keyListeners.onOtherKeyUp) } enableInventoryKeys() { document.addEventListener("keydown", this.keyListeners.onInventoryKeyDown), document.addEventListener("keyup", this.keyListeners.onInventoryKeyUp) } disableInventoryKeys() { document.removeEventListener("keydown", this.keyListeners.onInventoryKeyDown), document.removeEventListener("keyup", this.keyListeners.onInventoryKeyUp) } enableInteractKeys() { document.addEventListener("keydown", this.keyListeners.onInteractKeyDown), document.addEventListener("keyup", this.keyListeners.onInteractKeyUp) } disableInteractKeys() { document.removeEventListener("keydown", this.keyListeners.onInteractKeyDown), document.removeEventListener("keyup", this.keyListeners.onInteractKeyUp) } enableEventListeners() { this.scene.addEventListener(this.scene.eventTypes.INVENTORY_OPENED, this.eventListeners.onInventoryOpened), this.scene.addEventListener(this.scene.eventTypes.INVENTORY_CLOSED, this.eventListeners.onInventoryClosed), this.scene.addEventListener(this.scene.eventTypes.CHEST_OPENED, this.eventListeners.onChestOpened), this.scene.addEventListener(this.scene.eventTypes.CHEST_CLOSED, this.eventListeners.onChestClosed), this.scene.addEventListener(this.scene.eventTypes.TEXTBOX_OPENED, this.eventListeners.onTextBoxOpen), this.scene.addEventListener(this.scene.eventTypes.TEXTBOX_CLOSED, this.eventListeners.onTextBoxClose) } onInventoryOpened(t) { this.disableMovementKeys(), this.disableInteractKeys(), this.disableOtherKeys() } onInventoryClosed(t) { this.enableMovementKeys(), this.enableInteractKeys(), this.enableOtherKeys() } onChestOpened(t) { this.disableMovementKeys(), this.disableInventoryKeys(), this.disableOtherKeys() } onChestClosed(t) { this.enableMovementKeys(), this.enableInventoryKeys(), this.enableOtherKeys() } onTextBoxOpen(t) { this.disableAll() } onTextBoxClose(t) { this.enableAll() } disableAll() { this.disableMovementKeys(), this.disableInteractKeys(), this.disableInventoryKeys(), this.disableOtherKeys() } enableAll() { this.enableMovementKeys(), this.enableInteractKeys(), this.enableInventoryKeys(), this.enableOtherKeys() } onMovementKeyDown(t) { if (!t.repeat) switch (t.key.toLocaleLowerCase()) { case f.RIGHT: case "arrowright": this.controls[f.RIGHT] = !0; break; case f.LEFT: case "arrowleft": this.controls[f.LEFT] = !0; break; case f.UP: case "arrowup": this.controls[f.UP] = !0; break; case f.DOWN: case "arrowdown": this.controls[f.DOWN] = !0 } } onMovementKeyUp(t) { if (!t.repeat) switch (t.key.toLocaleLowerCase()) { case f.RIGHT: case "arrowright": this.controls[f.RIGHT] = !1; break; case f.LEFT: case "arrowleft": this.controls[f.LEFT] = !1; break; case f.UP: case "arrowup": this.controls[f.UP] = !1; break; case f.DOWN: case "arrowdown": this.controls[f.DOWN] = !1 } } onOtherKeyDown(t) { if (!t.repeat) switch (t.key.toLocaleLowerCase()) { case "l": this.controls.hotbar_left = !0; break; case ";": this.controls.hotbar_right = !0; break; case "f": this.controls.dig = !0 } } onOtherKeyUp(t) { if (!t.repeat) switch (t.key.toLocaleLowerCase()) { case "l": this.controls.hotbar_left = !1; break; case ";": this.controls.hotbar_right = !1; break; case "f": this.controls.dig = !1 } } onInventoryKeyDown(t) { t.repeat || "i" !== t.key.toLocaleLowerCase() || (this.controls.toggle_inventory = !0) } onInventoryKeyUp(t) { t.repeat || "i" !== t.key.toLocaleLowerCase() || (this.controls.toggle_inventory = !1) } onInteractKeyDown(t) { t.repeat || " " !== t.key.toLocaleLowerCase() || (this.controls.interact = !0) } onInteractKeyUp(t) { t.repeat || " " !== t.key.toLocaleLowerCase() || (this.controls.interact = !1) } update(t) { this.updateMovement(t), this.updateInteract(), this.updatePickupObject(), this.updateHotbar(), this.updateToggleInventory(), this.updateDig(), this.updateClick() } render(t) { let i = this.isIdle ? this.animationsIdle : this.animations; e.renderSprite(t, this.assets.images.tileset_player, i[this.direction][this.animationIndex].x, i[this.direction][this.animationIndex].y, this.transform.position.x, this.transform.position.y) } updateMovement(t) { this.determineNextMovement(t), this.processAnimations(t), this.processMovement(t) } determineNextMovement(t) { if (this.targetX !== this.transform.position.x || this.targetY !== this.transform.position.y) return; if (!(this.controls[f.RIGHT] || this.controls[f.LEFT] || this.controls[f.UP] || this.controls[f.DOWN])) return; let e, i = new l(this.transform.position.x, this.transform.position.y, this.targetX, this.targetY); this.controls[f.RIGHT] ? (i.targetX += 1, e = f.RIGHT) : this.controls[f.LEFT] ? (i.targetX -= 1, e = f.LEFT) : this.controls[f.UP] ? (i.targetY -= 1, e = f.UP) : this.controls[f.DOWN] && (i.targetY += 1, e = f.DOWN), this.direction !== e ? (this.direction = e, this.directionTime = 0, this.directionTimer = 0) : this.directionTimer += t, this.directionTimer < .05 || this.scene.hasCollisionAtPosition(i.targetX, i.targetY) || this.scene.willHaveCollisionAtPosition(i.targetX, i.targetY) || this.scene.isOutOfBounds(i.targetX, i.targetY) || (this.targetX = i.targetX, this.targetY = i.targetY) } processAnimations(t) { this.targetX !== this.transform.position.x || this.targetY !== this.transform.position.y ? this.isIdle = !1 : this.isIdle = !0, this.isIdle ? this.directionTime < .5 ? this.animationIndex = 0 : this.animationIndex = 1 : this.directionTime < .25 ? this.animationIndex = 0 : this.directionTime < .5 ? this.animationIndex = 1 : this.directionTime < .75 ? this.animationIndex = 0 : this.animationIndex = 1, this.directionTime = (this.directionTime + t) % 1 } processMovement(t) { if (this.targetX !== this.transform.position.x || this.targetY !== this.transform.position.y) { let e = new l(this.transform.position.x, this.transform.position.y, this.targetX, this.targetY), i = p.moveTowardsPosition(e, p.frameVelocity(this.movementSpeed, t)); this.transform.position.x = i.positionX, this.transform.position.y = i.positionY } } updateInteract() { if (!this.controls.interact) return; let t = this.getPositionFacing(), e = this.scene.getObjectAtPosition(t.x, t.y, null); !0 === (e && function (t) { return "interact" in t }(e)) ? e.interact() : this.updateInteractDefault(t), this.controls.interact = !1 } updateInteractChest(t) { this.scene.dispatchEvent(this.scene.eventTypes.TOGGLE_CHEST, { object: t }) } updateInteractDefault(t) { let e = this.scene.globals.hotbar_selected_index, i = this.scene.globals.inventory[e]; if (void 0 !== i && !this.scene.hasOrWillHaveCollisionAtPosition(t.x, t.y) && (i.type === L.Chicken || i.type === L.Egg)) { let s = function (t) { switch (t) { case L.Chicken: return I; case L.Egg: return u; case L.WheatSeeds: return x; case L.TomatoSeeds: return T } }(i.type), n = Reflect.construct(s, [this.scene, { positionX: t.x, positionY: t.y }]); this.scene.addObject(n), this.scene.removeFromInventory(e) } } updatePickupObject() { } destroy() { } getPositionFacing() { let t = Math.floor(this.transform.position.x), e = Math.floor(this.transform.position.y); return this.direction === f.RIGHT ? { x: t + 1, y: e } : this.direction === f.LEFT ? { x: t - 1, y: e } : this.direction === f.UP ? { x: t, y: e - 1 } : this.direction === f.DOWN ? { x: t, y: e + 1 } : void 0 } updateHotbar() { this.controls.hotbar_left && (this.controls.hotbar_left = !1, this.scene.globals.hotbar_selected_index = (this.scene.globals.hotbar_selected_index - 1 + this.scene.globals.hotbar_size) % this.scene.globals.hotbar_size), this.controls.hotbar_right && (this.controls.hotbar_right = !1, this.scene.globals.hotbar_selected_index = (this.scene.globals.hotbar_selected_index + 1) % this.scene.globals.hotbar_size) } updateToggleInventory() { this.controls.toggle_inventory && (this.scene.dispatchEvent(this.scene.eventTypes.TOGGLE_INVENTORY, {}), this.controls.toggle_inventory = !1) } updateDig() { if (!this.controls.dig) return; let t = this.getPositionFacing(); void 0 === this.scene.getObjectAtPosition(t.x, t.y, null) && (this.scene.addObject(new X(this.scene, { positionX: t.x, positionY: t.y })), this.scene.dispatchEvent(this.scene.eventTypes.DIRT_PLACED, { x: t.x, y: t.y }), this.controls.dig = !1) } updateClick() { if (!this.scene.globals.mouse.click.left) return; this.scene.globals.mouse.click.left = !1; let t = Math.ceil(this.scene.globals.mouse.position.x + this.scene.globals.camera.startX), e = Math.ceil(this.scene.globals.mouse.position.y + this.scene.globals.camera.startY); console.log("click", t, e) } } const k = { tileset: "tileset_dirt", animationFrameDuration: 1, animationFrames: [], animationMap: [1] }, j = { ...k, animationFrames: [{ spriteX: 0, spriteY: 0 }] }, A = { ...k, animationFrames: [{ spriteX: 1, spriteY: 0 }] }, H = { ...k, animationFrames: [{ spriteX: 2, spriteY: 0 }] }, D = { ...k, animationFrames: [{ spriteX: 0, spriteY: 1 }] }, M = { ...k, animationFrames: [{ spriteX: 1, spriteY: 1 }] }, N = { ...k, animationFrames: [{ spriteX: 2, spriteY: 1 }] }, R = { ...k, animationFrames: [{ spriteX: 0, spriteY: 2 }] }, B = { ...k, animationFrames: [{ spriteX: 1, spriteY: 2 }] }, F = { index: 0, tiles: [[], [], [], [], [], [], [], [], [], [], [], [void 0, void 0, void 0, void 0, void 0, j, D, D, D, D, D, R], [void 0, void 0, void 0, void 0, void 0, A, M, M, M, M, M, B], [void 0, void 0, void 0, void 0, void 0, A, M, M, M, M, M, B], [void 0, void 0, void 0, void 0, void 0, A, M, M, M, M, M, B], [void 0, void 0, void 0, void 0, void 0, A, M, M, M, M, M, B], [void 0, void 0, void 0, void 0, void 0, A, M, M, M, M, M, B], [void 0, void 0, void 0, void 0, void 0, H, N, N, N, N, N, { ...k, animationFrames: [{ spriteX: 2, spriteY: 2 }] }]] }, P = { index: 1, tiles: [] }, V = t.CANVAS_TILE_WIDTH / 2, G = t.CANVAS_TILE_HEIGHT / 2; class z extends c { constructor(e, i) { var s, n, o, r, a; super(e, i), this.scene = e, this.isRenderable = !0, this.renderLayer = t.UI_RENDER_LAYER, this.animationTimer = 0, this.animationType = null !== (s = i.animationType) && void 0 !== s ? s : "block", this.animationDirection = null !== (n = i.animationDirection) && void 0 !== n ? n : "in", this.animationLength = null !== (o = i.animationLength) && void 0 !== o ? o : 1, this.animationCenterX = null !== (r = i.animationCenterX) && void 0 !== r ? r : V, this.animationCenterY = null !== (a = i.animationCenterY) && void 0 !== a ? a : G } update(t) { this.animationTimer += t, this.animationTimer > this.animationLength && this.scene.removeObjectById(this.id) } get animationPercentage() { return this.animationTimer / this.animationLength } render(t) { switch (this.animationType) { case "block": this.renderAnimationBlock(t); break; case "circle": this.renderAnimationCircle(t) } } renderAnimationBlock(i) { let s = "in" === this.animationDirection ? 1 - this.animationPercentage : this.animationPercentage; e.fillRectangle(i, 0, 0, t.CANVAS_WIDTH, t.CANVAS_HEIGHT, { colour: `rgba(0, 0, 0, ${s})` }) } renderAnimationCircle(e) { let i = "in" === this.animationDirection ? this.animationPercentage : 1 - this.animationPercentage, s = this.animationCenterX - this.scene.globals.camera.startX, n = this.animationCenterY - this.scene.globals.camera.startY; e.fillStyle = "black", e.beginPath(), e.arc(s * t.TILE_SIZE + t.TILE_SIZE / 2, n * t.TILE_SIZE + t.TILE_SIZE / 2, t.CANVAS_WIDTH * i, 0, 2 * Math.PI), e.rect(t.CANVAS_WIDTH, 0, -1 * t.CANVAS_WIDTH, t.CANVAS_HEIGHT), e.fill() } destroy() { console.log("[TransitionObject] animation complete") } } class W extends c { constructor(t, e) { super(t, e), this.scene = t, this.hasCollision = !0 } } const K = () => { }; class U extends c { constructor(t, e) { var i, s; super(t, e), this.scene = t, this.timer = 0, this.duration = null !== (i = e.duration) && void 0 !== i ? i : 1, this.onComplete = null !== (s = e.onComplete) && void 0 !== s ? s : K } update(t) { this.timer += t, this.timer >= this.duration && (this.onComplete(), this.scene.removeObjectById(this.id)) } destroy() { console.log("[TimerObject] destroyed") } } class Z { } Z.TopLeft = { x: 1, y: 0 }, Z.TopRight = { x: 3, y: 0 }, Z.BottomLeft = { x: 1, y: 2 }, Z.BottomRight = { x: 3, y: 2 }, Z.MiddleHorizontal = { x: 2, y: 3 }, Z.MiddleVertical = { x: 0, y: 1 }, Z.FencePost = { x: 0, y: 3 }, Z.Open = { x: .5, y: 3 }; class $ extends c { constructor(t, e) { super(t, e), this.scene = t, this.isRenderable = !0, this.hasCollision = !0, this.width = 1, this.height = 1, this.type = Z.FencePost, this.open = !1, e.type && (this.type = e.type) } render(t) { e.renderSprite(t, this.assets.images.tileset_fence, this.open ? Z.Open.x : this.type.x, this.open ? Z.Open.y : this.type.y, this.transform.position.x, this.transform.position.y) } interact() { this.open ? (this.open = !1, this.hasCollision = !0) : (this.open = !0, this.hasCollision = !1) } } class J extends c { constructor(t, e) { super(t, e), this.scene = t, this.isRenderable = !0, this.playerConsumed = !1 } update(t) { let e = this.scene.getAllObjectsAtPosition(this.transform.position.x, this.transform.position.y); 1 !== e.length && e.forEach((t => { if (t !== this) { if (t instanceof O) { if (this.playerConsumed) return; let t = 2; return this.scene.addObject(new U(this.scene, { duration: t, onComplete: () => { this.scene.flagForMapChange(jt) } })), this.scene.addObject(new z(this.scene, { animationType: "circle", animationDirection: "out", animationCenterX: this.transform.position.x, animationCenterY: this.transform.position.y, animationLength: t })), void (this.playerConsumed = !0) } this.scene.removeObjectById(t.id) } })) } render(t) { e.renderCircle(t, this.transform.position.x, this.transform.position.y) } } const q = { tileset: "tileset_water", animationFrameDuration: 1, animationFrames: [{ spriteX: 0, spriteY: 0 }, { spriteX: 1, spriteY: 0 }, { spriteX: 2, spriteY: 0 }, { spriteX: 3, spriteY: 0 }], animationMap: [.25, .5, .75, 1] }, Q = [q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q], tt = { index: 0, tiles: [[...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q], [...Q]] }, et = { tileset: "tileset_grass", animationFrameDuration: 1, animationFrames: [], animationMap: [1] }, it = { ...et, animationFrames: [{ spriteX: 0, spriteY: 1 }] }, st = { ...et, animationFrames: [{ spriteX: 0, spriteY: 0 }] }, nt = { ...et, animationFrames: [{ spriteX: 0, spriteY: 2 }] }, ot = { ...et, animationFrames: [{ spriteX: 1, spriteY: 1 }] }, rt = { ...et, animationFrames: [{ spriteX: 1, spriteY: 0 }] }, at = { ...et, animationFrames: [{ spriteX: 1, spriteY: 2 }] }, ht = { ...et, animationFrames: [{ spriteX: 2, spriteY: 0 }] }, ct = { ...et, animationFrames: [{ spriteX: 2, spriteY: 1 }] }, dt = { index: 1, tiles: [[], [], [void 0, void 0, st, it, it, it, it, it, it, it, it, it, nt], [void 0, void 0, rt, ot, ot, ot, ot, ot, ot, ot, ot, ot, at], [void 0, void 0, rt, ot, ot, ot, ot, ot, ot, ot, ot, ot, at], [void 0, void 0, rt, ot, ot, ot, ot, ot, ot, ot, ot, ot, at], [void 0, void 0, rt, ot, ot, ot, ot, ot, ot, ot, ot, ot, at], [void 0, void 0, rt, ot, ot, ot, ot, ot, ot, ot, ot, ot, at], [void 0, void 0, rt, ot, ot, ot, ot, ot, ot, ot, ot, ot, at], [void 0, void 0, rt, ot, ot, ot, ot, ot, ot, ot, ot, ot, at], [void 0, void 0, rt, ot, ot, ot, ot, ot, ot, ot, ot, ot, at], [void 0, void 0, rt, ot, ot, ot, ot, ot, ot, ot, ot, ot, at], [void 0, void 0, rt, ot, ot, ot, ot, ot, ot, ot, ot, ot, at], [void 0, void 0, rt, ot, ot, ot, ot, ot, ot, ot, ot, ot, at], [void 0, void 0, rt, ot, ot, ot, ot, ot, ot, ot, ot, ot, at], [void 0, void 0, rt, ot, ot, ot, ot, ot, ot, ot, ot, ot, at], [void 0, void 0, rt, ot, ot, ot, ot, ot, ot, ot, ot, ot, at], [void 0, void 0, rt, ot, ot, ot, ot, ot, ot, ot, ot, ot, at], [void 0, void 0, ht, ct, ct, ct, ct, ct, ct, ct, ct, ct, { ...et, animationFrames: [{ spriteX: 2, spriteY: 2 }] }]] }, lt = { tileset: "", animationFrameDuration: 1, animationFrames: [{ spriteX: 0, spriteY: 0 }], animationMap: [1], tileset: "tileset_wood_bridge" }, pt = { ...lt, animationFrames: [{ spriteX: 2, spriteY: 0 }] }, gt = { ...lt, animationFrames: [{ spriteX: 3, spriteY: 0 }] }, mt = { index: 2, tiles: [[pt], [gt], [gt], [gt], [gt], [{ ...lt, animationFrames: [{ spriteX: 4, spriteY: 0 }] }]] }; class ut extends c { constructor(i, s) { super(i, s), this.scene = i, this.customerRenderer = i => { let s = this.object.positionX - this.cameraOffsetX, n = this.object.positionY - this.cameraOffsetY, o = this.object.positionX + (this.cameraOffsetX + 1), r = this.object.positionY + (this.cameraOffsetY + 1); s < 0 ? (s = 0, o = s + t.CANVAS_TILE_WIDTH) : o > this.scene.map.width && (o = this.scene.map.width, s = o - t.CANVAS_TILE_WIDTH), n < 0 ? (n = 0, r = n + t.CANVAS_TILE_HEIGHT) : r > this.scene.map.height && (r = this.scene.map.height, n = r - t.CANVAS_TILE_HEIGHT), this.scene.globals.camera.startX = s, this.scene.globals.camera.startY = n, this.scene.globals.camera.endX = o, this.scene.globals.camera.endY = r, i.background.forEach((t => { e.renderSubsection(t, this.mainContext, s, n, o, r) })), i.objects.forEach(((i, a) => { a === t.UI_RENDER_LAYER ? e.renderSubsection(i, this.mainContext, 0, 0, t.CANVAS_TILE_WIDTH, t.CANVAS_TILE_HEIGHT) : e.renderSubsection(i, this.mainContext, s, n, o, r) })) }; let n = t.CANVAS_TILE_WIDTH / 2 - .5, o = t.CANVAS_TILE_HEIGHT / 2 - .5; this.cameraOffsetX = s.zoom ? n / s.zoom : n, this.cameraOffsetY = s.zoom ? o / s.zoom : o, this.object = s.object, this.scene.setCustomRenderer(this.customerRenderer) } destroy() { this.scene.removeCustomerRenderer() } } const yt = t.UI_RENDER_LAYER, bt = t.UI_COLLISION_LAYER, vt = [{ x: 6, y: 15 }, { x: 8, y: 15 }, { x: 10, y: 15 }, { x: 12, y: 15 }, { x: 14, y: 15 }, { x: 16, y: 15 }, { x: 18, y: 15 }, { x: 20, y: 15 }, { x: 22, y: 15 }, { x: 6, y: 8 }, { x: 8, y: 8 }, { x: 10, y: 8 }, { x: 12, y: 8 }, { x: 14, y: 8 }, { x: 16, y: 8 }, { x: 18, y: 8 }, { x: 20, y: 8 }, { x: 22, y: 8 }, { x: 6, y: 10 }, { x: 8, y: 10 }, { x: 10, y: 10 }, { x: 12, y: 10 }, { x: 14, y: 10 }, { x: 16, y: 10 }, { x: 18, y: 10 }, { x: 20, y: 10 }, { x: 22, y: 10 }, { x: 6, y: 12 }, { x: 8, y: 12 }, { x: 10, y: 12 }, { x: 12, y: 12 }, { x: 14, y: 12 }, { x: 16, y: 12 }, { x: 18, y: 12 }, { x: 20, y: 12 }, { x: 22, y: 12 }], It = [{ x: 6, y: 1 }, { x: 8, y: 1 }, { x: 10, y: 1 }, { x: 12, y: 1 }, { x: 14, y: 1 }, { x: 16, y: 1 }, { x: 18, y: 1 }, { x: 20, y: 1 }, { x: 22, y: 1 }, { x: 6, y: 3 }, { x: 8, y: 3 }, { x: 10, y: 3 }, { x: 12, y: 3 }, { x: 14, y: 3 }, { x: 16, y: 3 }, { x: 18, y: 3 }, { x: 20, y: 3 }, { x: 22, y: 3 }, { x: 6, y: 5 }, { x: 8, y: 5 }, { x: 10, y: 5 }, { x: 12, y: 5 }, { x: 14, y: 5 }, { x: 16, y: 5 }, { x: 18, y: 5 }, { x: 20, y: 5 }, { x: 22, y: 5 }]; class Et extends c { constructor(t, e) { super(t, e), this.scene = t, this.isRenderable = !0, this.renderLayer = yt, this.collisionLayer = bt, this.showChest = !1, this.showInventory = !1, this.showHotbar = !0, this.chest = void 0, this.itemHolding = void 0, this.keyListeners.onMouseDown = this.onMouseDown.bind(this), this.keyListeners.onMouseUp = this.onMouseUp.bind(this), this.disableClickListeners(), this.scene.addEventListener(this.scene.eventTypes.TOGGLE_INVENTORY, this.onToggleInventory.bind(this)), this.scene.addEventListener(this.scene.eventTypes.CHEST_OPENED, this.onChestOpened.bind(this)), this.scene.addEventListener(this.scene.eventTypes.CHEST_CLOSED, this.onChestClosed.bind(this)) } onToggleInventory(t) { this.showInventory ? (this.disableClickListeners(), this.scene.dispatchEvent(this.scene.eventTypes.INVENTORY_CLOSED)) : (this.enableClickListeners(), this.scene.dispatchEvent(this.scene.eventTypes.INVENTORY_OPENED)), this.showInventory = !this.showInventory } onChestOpened(t) { this.chest = t.detail.object, this.showChest = !0, this.showInventory = !0, this.showHotbar = !0, this.enableClickListeners() } onChestClosed(t) { this.chest = void 0, this.showChest = !1, this.showInventory = !1, this.showHotbar = !0, this.disableClickListeners() } render(t) { if (this.showHotbar) { let e = 6, i = 15; this.renderInventoryBackground(t, e, i), this.renderInventoryContainers(t, e, i), this.renderInventoryItems(t, e, i, this.inventory.slice(0, this.hotbarSize)), this.showInventory || this.renderHotbarSelector(t) } if (this.showChest) { this.renderChestHeader(t, 6, 0); for (let e = 0; e < 3; e++) { let i = 6, s = 1 + 2 * e; this.renderInventoryBackground(t, i, s), this.renderInventoryContainers(t, i, s), this.renderInventoryItems(t, i, s, this.chest.inventory.slice(this.hotbarSize * e, this.hotbarSize * (e + 1))) } } if (this.showInventory) { this.renderInventoryHeader(t, 6, 7); for (let e = 0; e < 3; e++) { let i = 6, s = 8 + 2 * e; this.renderInventoryBackground(t, i, s), this.renderInventoryContainers(t, i, s), this.renderInventoryItems(t, i, s, this.inventory.slice(this.hotbarSize * (e + 1), this.hotbarSize * (e + 2))) } this.renderInventoryItemGrabbed(t) } } renderHotbarSelector(t) { const i = 6 + 2 * this.hotbarSelectedIndex; e.renderSprite(t, this.assets.images.tileset_ui, 9, 9, i, 15, 2, 2) } renderInventoryHeader(i, s, n) { let o = 4 * t.TILE_SIZE, r = 2 * t.TILE_SIZE; e.fillRectangle(i, s, n, o, r, { colour: "saddlebrown" }), e.renderText(i, "Inventory", s + .4, n + .75, { size: 12, colour: "white" }) } renderChestHeader(i, s, n) { let o = 4 * t.TILE_SIZE, r = 2 * t.TILE_SIZE; e.fillRectangle(i, s, n, o, r, { colour: "saddlebrown" }), e.renderText(i, "Chest", s + .9, n + .75, { size: 12, colour: "white" }) } renderInventoryBackground(i, s, n) { let o = 18 * t.TILE_SIZE, r = 2 * t.TILE_SIZE; e.fillRectangle(i, s, n, o, r, { colour: "saddlebrown" }) } renderInventoryContainers(t, i, s) { for (let n = 0; n < 9; n++)e.renderSprite(t, this.assets.images.tileset_ui, .5, 3.5, i + 2 * n, s, 2, 2) } renderInventoryItems(t, e, i, s) { for (let n = 0; n < 9; n++) { let o = s[n]; void 0 !== o && this.renderInventoryItem(t, o.sprite.tileset, o.currentStackSize, o.sprite.spriteX, o.sprite.spriteY, e + .5 + 2 * n, i + .5) } } renderInventoryItemGrabbed(t) { if (void 0 === this.itemHolding) return; let e = this.itemHolding.item; this.renderInventoryItem(t, e.sprite.tileset, e.currentStackSize, e.sprite.spriteX, e.sprite.spriteY, this.scene.globals.mouse.position.exactX - .5, this.scene.globals.mouse.position.exactY - .5) } get inventory() { return this.scene.globals.inventory } get inventorySize() { return this.scene.globals.inventory_size } get hotbarSize() { return this.scene.globals.hotbar_size } get hotbarSelectedIndex() { return this.scene.globals.hotbar_selected_index } onMouseDown(t) { let e = o.getMousePosition(this.mainContext.canvas, t), i = this.getIndexFromPositionMap(e, vt); if (void 0 !== i) { let t = this.inventory[i]; if (void 0 === t) return; return void (this.itemHolding = { location: "inventory", item: t, index: i }) } let s = this.getIndexFromPositionMap(e, It); if (void 0 === s) this.itemHolding = void 0; else { let t = this.chest.inventory[s]; if (void 0 === t) return; this.itemHolding = { location: "chest", item: t, index: s } } } onMouseUp(t) { if (void 0 === this.itemHolding) return; let e = o.getMousePosition(this.mainContext.canvas, t), i = this.getIndexFromPositionMap(e, vt); if (void 0 !== i) { let t = this.inventory[i]; return "inventory" === this.itemHolding.location ? (this.inventory[i] = this.itemHolding.item, this.inventory[this.itemHolding.index] = t) : "chest" === this.itemHolding.location && (this.inventory[i] = this.itemHolding.item, this.chest.inventory[this.itemHolding.index] = t), void (this.itemHolding = void 0) } let s = this.getIndexFromPositionMap(e, It); if (void 0 !== s) { let t = this.chest.inventory[s]; return "inventory" === this.itemHolding.location ? (this.chest.inventory[s] = this.itemHolding.item, this.inventory[this.itemHolding.index] = t) : "chest" === this.itemHolding.location && (this.chest.inventory[s] = this.itemHolding.item, this.chest.inventory[this.itemHolding.index] = t), void (this.itemHolding = void 0) } this.itemHolding = void 0 } enableClickListeners() { this.mainContext.canvas.addEventListener("mousedown", this.keyListeners.onMouseDown), this.mainContext.canvas.addEventListener("mouseup", this.keyListeners.onMouseUp) } disableClickListeners() { this.mainContext.canvas.removeEventListener("mousedown", this.keyListeners.onMouseDown), this.mainContext.canvas.removeEventListener("mouseup", this.keyListeners.onMouseUp) } renderInventoryItem(t, i, s, n, o, r, a) { e.renderSprite(t, this.assets.images[i], n, o, r, a), e.renderText(t, `${s}`, r + .75, a + 1, { size: 8, colour: "black" }) } getIndexFromPositionMap(t, e) { for (let i = 0; i < e.length; i++) { let s = e[i]; if (t.x >= s.x && t.x <= s.x + 1 && t.y >= s.y && t.y <= s.y + 1) return i } } } const Tt = "tileset_chest"; class xt extends c { constructor(t, e) { super(t, e), this.scene = t, this.hasCollision = !0, this.isRenderable = !0, this.renderLayer = 8, this.width = 1, this.height = 1, this.isOpen = !1, this.inventory = [], this.eventListeners.onToggleChest = this.onToggleChest.bind(this), this.enableEventListeners() } enableEventListeners() { this.scene.addEventListener(this.scene.eventTypes.TOGGLE_CHEST, this.eventListeners.onToggleChest) } onToggleChest(t) { this.isOpen ? this.closeChest() : t.detail.object === this && this.openChest() } openChest() { this.scene.dispatchEvent(this.scene.eventTypes.CHEST_OPENED, { object: this }), this.isOpen = !0 } closeChest() { this.scene.dispatchEvent(this.scene.eventTypes.CHEST_CLOSED, { object: this }), this.isOpen = !1 } render(t) { this.renderSprite(t) } renderSprite(t) { this.isOpen ? e.renderSprite(t, this.scene.assets.images[Tt], 13, .5, this.transform.position.x, this.transform.position.y - .5, 1, 2) : e.renderSprite(t, this.scene.assets.images[Tt], 1, .5, this.transform.position.x, this.transform.position.y - .5, 1, 2) } interact() { this.isOpen ? this.closeChest() : this.openChest() } } const Lt = () => { }; class wt extends c { constructor(t, e) { var i, s, n; super(t, e), this.scene = t, this.timer = 0, this.intervalsComplete = 0, this.duration = null !== (i = e.duration) && void 0 !== i ? i : 1, this.onInterval = null !== (s = e.onInterval) && void 0 !== s ? s : Lt, this.onDestroy = null !== (n = e.onDestroy) && void 0 !== n ? n : void 0, this.maxIntervals = e.maxIntervals } update(t) { this.timer += t, this.timer >= this.duration && (this.onInterval(), this.timer -= this.duration, this.intervalsComplete++, this.maxIntervals && this.intervalsComplete >= this.maxIntervals && this.scene.removeObjectById(this.id)) } destroy() { this.onDestroy && this.onDestroy(), console.log("[IntervalObject] destroyed") } } class Ct extends n { constructor(t) { super(t), this.scene = t, this.height = 100, this.width = 100, this.backgroundLayers = [tt, dt, mt], this.objects = [], o.setCursor(this.context.canvas, "/assets/sample/Mouse sprites/Triangle Mouse icon 1.png"), this.objects.push(new Et(t, { positionX: 0, positionY: 0 })), this.objects.push(new J(t, { positionX: 17, positionY: 3 })); let e = new O(t, { positionX: 4, positionY: 4 }); this.objects.push(e), this.objects.push(new xt(t, { positionX: 3, positionY: 3 })), this.objects.push(new xt(t, { positionX: 4, positionY: 3 })), this.objects.push(new xt(t, { positionX: 5, positionY: 3 })), this.objects.push(new I(t, { positionX: 17, positionY: 11, follows: e, canLayEggs: !0, canMove: !0 })), this.objects.push(new $(t, { positionX: 2, positionY: 2, type: Z.TopLeft })), this.objects.push(new $(t, { positionX: 3, positionY: 2, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 4, positionY: 2, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 5, positionY: 2, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 6, positionY: 2, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 7, positionY: 2, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 8, positionY: 2, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 9, positionY: 2, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 10, positionY: 2, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 11, positionY: 2, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 12, positionY: 2, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 13, positionY: 2, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 14, positionY: 2, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 15, positionY: 2, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 16, positionY: 2, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 17, positionY: 2, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 18, positionY: 2, type: Z.TopRight })), this.objects.push(new $(t, { positionX: 2, positionY: 3, type: Z.MiddleVertical })), this.objects.push(new $(t, { positionX: 18, positionY: 3, type: Z.MiddleVertical })), this.objects.push(new $(t, { positionX: 2, positionY: 4, type: Z.MiddleVertical })), this.objects.push(new $(t, { positionX: 18, positionY: 4, type: Z.MiddleVertical })), this.objects.push(new $(t, { positionX: 2, positionY: 5, type: Z.MiddleVertical })), this.objects.push(new $(t, { positionX: 18, positionY: 5, type: Z.MiddleVertical })), this.objects.push(new $(t, { positionX: 2, positionY: 6, type: Z.MiddleVertical })), this.objects.push(new $(t, { positionX: 18, positionY: 6, type: Z.MiddleVertical })), this.objects.push(new $(t, { positionX: 2, positionY: 7, type: Z.MiddleVertical })), this.objects.push(new $(t, { positionX: 18, positionY: 7, type: Z.MiddleVertical })), this.objects.push(new $(t, { positionX: 2, positionY: 8, type: Z.MiddleVertical })), this.objects.push(new $(t, { positionX: 18, positionY: 8, type: Z.MiddleVertical })), this.objects.push(new $(t, { positionX: 2, positionY: 9, type: Z.MiddleVertical })), this.objects.push(new $(t, { positionX: 18, positionY: 9, type: Z.MiddleVertical })), this.objects.push(new $(t, { positionX: 2, positionY: 10, type: Z.MiddleVertical })), this.objects.push(new $(t, { positionX: 18, positionY: 10, type: Z.MiddleVertical })), this.objects.push(new $(t, { positionX: 2, positionY: 11, type: Z.MiddleVertical })), this.objects.push(new $(t, { positionX: 18, positionY: 11, type: Z.MiddleVertical })), this.objects.push(new $(t, { positionX: 2, positionY: 12, type: Z.BottomLeft })), this.objects.push(new $(t, { positionX: 3, positionY: 12, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 4, positionY: 12, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 5, positionY: 12, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 6, positionY: 12, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 7, positionY: 12, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 8, positionY: 12, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 9, positionY: 12, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 10, positionY: 12, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 11, positionY: 12, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 12, positionY: 12, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 13, positionY: 12, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 14, positionY: 12, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 15, positionY: 12, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 16, positionY: 12, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 17, positionY: 12, type: Z.MiddleHorizontal })), this.objects.push(new $(t, { positionX: 18, positionY: 12, type: Z.BottomRight })), this.objects.push(new ut(t, { object: e })), this.objects.push(new z(t, { animationCenterX: e.positionX, animationCenterY: e.positionY, animationType: "circle", animationLength: 1 })), this.objects.push(new wt(t, { duration: 1, onInterval: () => { }, onDestroy: () => { }, maxIntervals: 5 })), this.objects.push(new wt(t, { duration: 1, onInterval: () => { }, onDestroy: () => { } })), this.objects.push(new U(t, { duration: 1, onComplete: () => { } })) } } class _t extends c { constructor(t, e) { super(t, e), this.scene = t, this.isWarping = !1, this.player = e.player } update(t) { this.isWarping || this.transform.position.x === this.player.positionX && this.transform.position.y === this.player.positionY && (this.isWarping = !0, this.scene.addObject(new U(this.scene, { duration: 1.5, onComplete: () => { this.scene.changeMap(Ct) } })), this.scene.addObject(new z(this.scene, { animationType: "circle", animationDirection: "out", animationCenterX: this.transform.position.x, animationCenterY: this.transform.position.y, animationLength: 1.5 }))) } destroy() { } } const St = { unknown_npc_1: "Welcome. I have been expecting you. We all have.", unknown_npc_2: "If you do not do as we wish, a terrible plague will befall the land.", unknown_npc_3: "You have no idea of the power that we posess.", greg: { line_1: "Hi, I'm Greg.", line_2: "........", line_3: "Byeeeeeeee" } }; class Yt { constructor(t, e) { this.tileset = t, this.frames = e, this.duration = e.reduce(((t, e) => t + e.duration), 0) } currentFrame(t) { let e = t % this.duration, i = 0; for (let t = 0; t < this.frames.length; t++)if (i += this.frames[t].duration, e < i) return this.frames[t]; return this.frames[0] } } const Xt = { idle: new Yt("tileset_chicken", [{ spriteX: 0, spriteY: 0, duration: 3.5 }, { spriteX: 1, spriteY: 0, duration: .5 }]), moving: new Yt("tileset_chicken", [{ spriteX: 0, spriteY: 0, duration: 3.5 }, { spriteX: 1, spriteY: 0, duration: .5 }]) }; class ft extends c { constructor(t, e) { var i, s, n, o, r; super(t, e), this.scene = t, this.state = "idle", this.isRenderable = !0, this.hasCollision = !0, this.renderLayer = 8, this.width = 1, this.height = 1, this.animation = { index: 0, timer: 0 }, this.movementTimer = d.randomStartingDelta(2), this.canMove = null !== (i = e.canMove) && void 0 !== i && i, this.following = e.follows, this.dialogue = e.dialogue, this.animations = null !== (s = e.animations) && void 0 !== s ? s : Xt, this.movementSpeed = null !== (n = e.movementSpeed) && void 0 !== n ? n : 2, this.movementDelay = null !== (o = e.movementDelay) && void 0 !== o ? o : void 0, this.name = null !== (r = e.name) && void 0 !== r ? r : "???" } update(t) { this.updateMovement(t), this.updateAnimationTimer(t) } render(t) { let i = this.animations[this.state], s = i.currentFrame(this.animation.timer); e.renderSprite(t, this.assets.images[i.tileset], s.spriteX, s.spriteY, this.transform.position.x, this.transform.position.y, void 0, void 0, { opacity: this.renderOpacity, scale: this.renderScale }) } destroy() { console.log("[NpcObject#destroy]", this) } updateAnimationTimer(t) { this.animation.timer = (this.animation.timer + t) % this.animations[this.state].duration } updateMovement(t) { this.canMove && (this.movementTimer += t, (void 0 === this.movementDelay && this.movementTimer > this.movementSpeed || this.movementTimer > this.movementDelay) && this.determineNextMovement(t), this.processMovement(t)) } determineNextMovement(t) { let e; this.movementTimer = 0, e = this.following ? p.moveTowardsOtherEntity(new l(this.transform.position.x, this.transform.position.y, this.targetX, this.targetY), new l(this.following.positionX, this.following.positionY, this.following.targetX, this.following.targetY)) : p.moveInRandomDirection(new l(this.transform.position.x, this.transform.position.y, this.targetX, this.targetY)), this.scene.hasCollisionAtPosition(e.targetX, e.targetY, this) || this.scene.willHaveCollisionAtPosition(e.targetX, e.targetY, this) || this.scene.isOutOfBounds(e.targetX, e.targetY) || (this.targetX = e.targetX, this.targetY = e.targetY) } processMovement(t) { if (this.targetX !== this.transform.position.x || this.targetY !== this.transform.position.y) { let e = new l(this.transform.position.x, this.transform.position.y, this.targetX, this.targetY), i = p.moveTowardsPosition(e, p.frameVelocity(this.movementSpeed, t)); this.transform.position.x = i.positionX, this.transform.position.y = i.positionY } } interact() { if (console.log("[NpcObject#interact]"), void 0 === this.dialogue) return; let t = new v(this.scene, { text: this.dialogue, portrait: this.name, name: this.name }); this.scene.addObject(t) } } class Ot extends ft { constructor(t, e) { super(t, e), this.scene = t, this.stage = "idle", this.stagePauseTimer = 0, this.stagePauseDuration = 3, this.stageByeTimer = 0, this.stageByeDuration = 3 } update(t) { switch (super.update(t), this.stage) { case "idle": case "hi": break; case "pause": this.updateStagePause(t); break; case "bye": this.updateStageBye(t) } } interact() { console.log("[GregNpcObject#interact]"), "idle" === this.stage && this.startStageHi() } startStageHi() { this.stage = "hi", this.scene.addObject(new v(this.scene, { text: St.greg.line_1, portrait: this.name, name: this.name, onComplete: () => { this.startStagePause() } })) } startStagePause() { this.stage = "pause", this.scene.addObject(new v(this.scene, { showOverlay: !1, text: St.greg.line_2, portrait: this.name, name: this.name, onComplete: () => { this.startStageBye() } })) } updateStagePause(t) { } startStageBye() { this.stage = "bye", this.scene.addObject(new v(this.scene, { showOverlay: !1, text: St.greg.line_3, portrait: this.name, name: this.name, completionDuration: this.stageByeDuration })) } updateStageBye(t) { this.stageByeTimer += t, this.renderScale = 1 - this.stageByeTimer / this.stageByeDuration, this.stageByeTimer >= this.stageByeDuration && this.scene.removeObjectById(this.id) } } class kt extends ft { constructor(t, e) { super(t, e), this.scene = t, this.stage = "idle", this.stageOutroTimer = 0, this.stageOutroDuration = 1 } update(t) { switch (super.update(t), this.stage) { case "idle": case "intro": break; case "outro": this.updateStageOutro(t) } } interact() { console.log("[GregNpcObject#interact]"), "idle" === this.stage && this.startStageIntro() } startStageIntro() { this.stage = "intro", this.scene.addObject(new v(this.scene, { text: this.dialogue, portrait: this.name, name: this.name, onComplete: () => { this.startStageOutro() } })) } startStageOutro() { this.stage = "outro" } updateStageOutro(t) { this.stageOutroTimer += t, this.renderOpacity = 1 - this.stageOutroTimer / this.stageOutroDuration, this.stageOutroTimer >= this.stageOutroDuration && this.scene.removeObjectById(this.id) } } class jt extends n { constructor(t) { super(t), this.scene = t, this.height = 40, this.width = 40, this.backgroundLayers = [F, P], this.objects = []; let e = new O(t, { positionX: 14, positionY: 8 }); this.objects.push(e), this.objects.push(new z(t, { animationType: "block", animationLength: 2 })), this.objects.push(new Ot(t, { positionX: 14, positionY: 7, name: "Greg" })), this.objects.push(new kt(t, { positionX: 13, positionY: 8, dialogue: St.unknown_npc_1 })), this.objects.push(new kt(t, { positionX: 15, positionY: 8, dialogue: St.unknown_npc_2 })), this.objects.push(new kt(t, { positionX: 14, positionY: 9, dialogue: St.unknown_npc_3 })), this.objects.push(new W(t, { positionX: 11, positionY: 4 })), this.objects.push(new W(t, { positionX: 12, positionY: 4 })), this.objects.push(new W(t, { positionX: 13, positionY: 4 })), this.objects.push(new W(t, { positionX: 15, positionY: 4 })), this.objects.push(new W(t, { positionX: 16, positionY: 4 })), this.objects.push(new W(t, { positionX: 17, positionY: 4 })), this.objects.push(new W(t, { positionX: 10, positionY: 5 })), this.objects.push(new W(t, { positionX: 18, positionY: 5 })), this.objects.push(new W(t, { positionX: 10, positionY: 6 })), this.objects.push(new W(t, { positionX: 18, positionY: 6 })), this.objects.push(new W(t, { positionX: 10, positionY: 7 })), this.objects.push(new W(t, { positionX: 18, positionY: 7 })), this.objects.push(new W(t, { positionX: 10, positionY: 8 })), this.objects.push(new W(t, { positionX: 18, positionY: 8 })), this.objects.push(new W(t, { positionX: 10, positionY: 9 })), this.objects.push(new W(t, { positionX: 18, positionY: 9 })), this.objects.push(new W(t, { positionX: 10, positionY: 10 })), this.objects.push(new W(t, { positionX: 18, positionY: 10 })), this.objects.push(new W(t, { positionX: 10, positionY: 11 })), this.objects.push(new W(t, { positionX: 18, positionY: 11 })), this.objects.push(new W(t, { positionX: 11, positionY: 12 })), this.objects.push(new W(t, { positionX: 12, positionY: 12 })), this.objects.push(new W(t, { positionX: 13, positionY: 12 })), this.objects.push(new W(t, { positionX: 14, positionY: 12 })), this.objects.push(new W(t, { positionX: 15, positionY: 12 })), this.objects.push(new W(t, { positionX: 16, positionY: 12 })), this.objects.push(new W(t, { positionX: 17, positionY: 12 })), this.objects.push(new W(t, { positionX: 14, positionY: 0 })), this.objects.push(new W(t, { positionX: 13, positionY: 1 })), this.objects.push(new _t(t, { player: e, positionX: 14, positionY: 1 })), this.objects.push(new g(t, { tileset: "tileset_wood_bridge", spriteX: 0, spriteY: 0, positionX: 14, positionY: 1 })), this.objects.push(new W(t, { positionX: 15, positionY: 1 })), this.objects.push(new W(t, { positionX: 13, positionY: 2 })), this.objects.push(new g(t, { tileset: "tileset_wood_bridge", spriteX: 0, spriteY: 1, positionX: 14, positionY: 2 })), this.objects.push(new W(t, { positionX: 15, positionY: 2 })), this.objects.push(new W(t, { positionX: 13, positionY: 3 })), this.objects.push(new g(t, { tileset: "tileset_wood_bridge", spriteX: 0, spriteY: 1, positionX: 14, positionY: 3 })), this.objects.push(new W(t, { positionX: 15, positionY: 3 })), this.objects.push(new g(t, { tileset: "tileset_wood_bridge", spriteX: 0, spriteY: 1, positionX: 14, positionY: 4 })), this.objects.push(new g(t, { tileset: "tileset_wood_bridge", spriteX: 0, spriteY: 2, positionX: 14, positionY: 5 })) } } const At = { [L.Chicken]: 1, [L.Egg]: 9, [L.WheatSeeds]: 9, [L.TomatoSeeds]: 9 }, Ht = { [L.Chicken]: { tileset: "tileset_chicken", spriteX: 0, spriteY: 0 }, [L.Egg]: { tileset: "tileset_egg", spriteX: 0, spriteY: 0 }, [L.WheatSeeds]: { tileset: "tileset_plants", spriteX: 0, spriteY: 0 }, [L.TomatoSeeds]: { tileset: "tileset_plants", spriteX: 0, spriteY: 1 } }, Dt = { tileset: "tileset_ui", spriteX: 15, spriteY: 5 }; class Mt extends c { constructor(t, e) { var i, s; super(t, e), this.scene = t, this.type = e.type, this.maxStackSize = null !== (i = At[this.type]) && void 0 !== i ? i : 1, this.sprite = null !== (s = Ht[this.type]) && void 0 !== s ? s : Dt, void 0 !== e.currentStackSize ? this.currentStackSize = e.currentStackSize > this.maxStackSize ? this.maxStackSize : e.currentStackSize : this.currentStackSize = 1 } } class Nt { constructor(t) { this.client = t, this.backgroundLayersAnimationTimer = {}, this.objects = [], this.globals = { mouse: { click: { left: !1, middle: !1, right: !1 }, position: { x: 0, y: 0, exactX: 0, exactY: 0 } }, camera: { startX: 0, startY: 0, endX: 0, endY: 0 }, keyboard: {}, latestMouseEvent: new MouseEvent("") }, this.flaggedForMapChange = void 0, this.renderingContext = { background: [], objects: [] }, this.eventEmitter = document.createElement("eventEmitter"), this.eventTypes = {}, this.backgroundLayerAnimationFrame = {}, this.context = this.client.context, this.assets = this.client.assets, t.canvas.addEventListener("mousemove", (e => { this.globals.mouse.position = o.getMousePosition(t.canvas, e), this.globals.latestMouseEvent = e })), t.canvas.addEventListener("mousedown", (t => { switch (console.log("[mousedown]", t), t.button) { case 0: this.globals.mouse.click.left = !0; break; case 1: this.globals.mouse.click.middle = !0; break; case 2: this.globals.mouse.click.right = !0 } })), t.canvas.addEventListener("mouseup", (t => { switch (console.log("[mouseup]", t), t.button) { case 0: this.globals.mouse.click.left = !1; break; case 1: this.globals.mouse.click.middle = !1; break; case 2: this.globals.mouse.click.right = !1 } })), t.canvas.addEventListener("touchstart", (t => { console.log("[touchstart]", t), this.globals.mouse.click.left = !0 })), t.canvas.addEventListener("touchend", (t => { console.log("[touchend]", t), this.globals.mouse.click.left = !1 })), document.addEventListener("keydown", (t => { t.repeat || (console.log("[keydown]", t), this.globals.keyboard[t.key.toLocaleLowerCase()] = !0) })), document.addEventListener("keyup", (t => { t.repeat || (console.log("[keyup]", t), this.globals.keyboard[t.key.toLocaleLowerCase()] = !1) })) } frame(t) { this.renderBackground(t), this.updateObjects(t), this.renderObjects(t), this.customRenderer ? this.customRenderer(this.renderingContext) : this.defaultRenderer(), this.destroyObjects(t) } renderBackground(t) { this.client.debug.timing.frameBackground && console.time("[frame] background"), this.backgroundLayers.forEach(((i, s) => { let n = this.renderingContext.background[s]; e.clearCanvas(n); for (let s = 0; s < this.map.width; s++)for (let o = 0; o < this.map.height; o++) { let r, a = i.tiles[s] ? i.tiles[s][o] : void 0; if (void 0 !== a) { if (1 === a.animationFrames.length) r = a.animationFrames[0]; else { let e; void 0 === this.backgroundLayersAnimationTimer[i.index] && (this.backgroundLayersAnimationTimer[i.index] = {}), void 0 === this.backgroundLayersAnimationTimer[i.index][s] && (this.backgroundLayersAnimationTimer[i.index][s] = {}), e = void 0 === this.backgroundLayersAnimationTimer[i.index][s][o] ? 0 : this.backgroundLayersAnimationTimer[i.index][s][o] + t, e > a.animationFrameDuration && (e %= a.animationFrameDuration); for (let t = 0; t < a.animationMap.length; t++)if (e <= a.animationMap[t]) { r = a.animationFrames[t]; break } this.backgroundLayersAnimationTimer[i.index][s][o] = e } e.renderSprite(n, this.assets.images[a.tileset], r.spriteX, r.spriteY, s, o) } } })), this.client.debug.timing.frameBackground && console.timeEnd("[frame] background") } updateObjects(t) { this.client.debug.timing.frameUpdate && console.time("[frame] update"), this.objects.forEach((e => { e.update && e.update(t) })), this.client.debug.timing.frameUpdate && console.timeEnd("[frame] update") } renderObjects(t) { this.client.debug.timing.frameRender && console.time("[frame] render"), this.renderingContext.objects.forEach((t => { e.clearCanvas(t) })), this.objects.forEach((t => { this.client.debug.object.renderBackground && t.debuggerRenderBackground(this.renderingContext.objects[t.renderLayer]), t.render && t.isRenderable && t.render(this.renderingContext.objects[t.renderLayer]), this.client.debug.object.renderBoundary && t.debuggerRenderBoundary(this.renderingContext.objects[t.renderLayer]) })), this.client.debug.timing.frameRender && console.timeEnd("[frame] render") } destroyObjects(t) { this.client.debug.timing.frameDestroy && console.time("[frame] destroy"), this.objects.forEach((t => { t.flaggedForDestroy && this.removeObjectById(t.id) })), this.client.debug.timing.frameDestroy && console.timeEnd("[frame] destroy") } defaultRenderer() { this.globals.camera.startX = 0, this.globals.camera.startY = 0, this.globals.camera.endX = 0, this.globals.camera.endY = 0, this.renderingContext.background.forEach((t => { this.context.drawImage(t.canvas, 0, 0) })), this.renderingContext.objects.forEach((t => { this.context.drawImage(t.canvas, 0, 0) })) } addObject(t) { this.objects.push(t) } removeObjectById(t) { let e = this.objects.find((e => e.id === t)); void 0 !== e && (e.destroy && e.destroy(), this.objects.splice(this.objects.indexOf(e), 1)) } getObjectsByType(t) { return this.objects.filter((e => e instanceof t)) } hasCollisionAtPosition(t, e, i) { let s = this.objects.find((i => i.positionX === t && i.positionY === e && i.hasCollision)); return void 0 !== s && i !== s } willHaveCollisionAtPosition(t, e, i) { let s = this.objects.find((i => i.targetX === t && i.targetY === e && i.hasCollision)); return void 0 !== s && i !== s } isOutOfBounds(t, e) { return t > this.map.width - 1 || e > this.map.height - 1 || t < 0 || e < 0 } hasOrWillHaveCollisionAtPosition(t, e, i) { return this.hasCollisionAtPosition(t, e, i) || this.willHaveCollisionAtPosition(t, e, i) } getObjectAtPosition(e, i, s) { return this.objects.find((s => s.positionX === e && s.positionY === i && s.collisionLayer !== t.UI_COLLISION_LAYER)) } getAllObjectsAtPosition(e, i, s) { return this.objects.filter((s => s.positionX === e && s.positionY === i && s.collisionLayer !== t.UI_COLLISION_LAYER)) } removeAllObjects() { for (; this.objects.length > 0;)this.removeObjectById(this.objects[0].id) } removeAllBackgroundLayers() { this.backgroundLayers = [] } setUpRenderingContexts() { this.renderingContext = { background: [], objects: [] }; for (let t = 0; t < this.backgroundLayers.length; t++) { let i = this.createCanvas(); this.renderingContext.background[t] = e.getContext(i) } for (let i = 0; i < t.OBJECT_RENDERING_LAYERS; i++) { let t = this.createCanvas(); this.renderingContext.objects[i] = e.getContext(t) } } createCanvas() { let t = e.createCanvas(this.map.width, this.map.height); return this.client.debug.ui.canvasLayers && this.client.container.append(t), t } flagForMapChange(t) { this.flaggedForMapChange = t } changeMap(t) { void 0 !== this.map && this.map.destroy(), this.removeAllObjects(), this.removeAllBackgroundLayers(), console.log("[Scene] changing map to", t), this.map = Reflect.construct(t, [this]), this.backgroundLayers.push(...this.map.backgroundLayers), this.objects.push(...this.map.objects), this.setUpRenderingContexts(), this.flaggedForMapChange = void 0 } changeScene(t) { this.client.changeScene(t) } setCustomRenderer(t) { this.customRenderer = t } removeCustomerRenderer() { this.customRenderer = void 0 } addEventListener(t, e) { this.eventEmitter.addEventListener(t, e) } removeEventListener(t, e) { this.eventEmitter.removeEventListener(t, e) } dispatchEvent(t, e) { let i = new CustomEvent(t, { detail: e }); console.log("[dispatchEvent]", i), this.eventEmitter.dispatchEvent(i) } } const Rt = { TOGGLE_INVENTORY: "TOGGLE_INVENTORY", INVENTORY_OPENED: "INVENTORY_OPENED", INVENTORY_CLOSED: "INVENTORY_CLOSED", TOGGLE_CHEST: "TOGGLE_CHEST", CHEST_OPENED: "CHEST_OPENED", CHEST_CLOSED: "CHEST_CLOSED", DIRT_PLACED: "DIRT_PLACED", DIRT_REMOVED: "DIRT_REMOVED", TEXTBOX_OPENED: "TEXTBOX_OPENED", TEXTBOX_CLOSED: "TEXTBOX_CLOSED" }; class Bt extends Nt { constructor(t) { super(t), this.globals = { ...this.globals, inventory: [new Mt(this, { type: L.Chicken }), new Mt(this, { type: L.Egg }), new Mt(this, { type: L.TomatoSeeds, currentStackSize: 10 }), new Mt(this, { type: L.WheatSeeds, currentStackSize: 10 })], inventory_size: 36, hotbar_size: 9, hotbar_selected_index: 0 }, this.eventTypes = Rt, this.changeMap(jt) } get firstFreeInventorySpaceIndex() { for (let t = 0; t < this.globals.inventory_size; t++)if (void 0 === this.globals.inventory[t]) return t } getFirstInventoryItemWithRoomInStack(t) { for (let e = 0; e < this.globals.inventory_size; e++) { let i = this.globals.inventory[e]; if (void 0 !== i && i.type === t && i.currentStackSize < i.maxStackSize) return i } } addToInventory(t) { let e = this.getFirstInventoryItemWithRoomInStack(t); if (void 0 !== e) return void e.currentStackSize++; let i = this.firstFreeInventorySpaceIndex; if (void 0 === i) return; let s = new Mt(this, { type: t }); this.globals.inventory[i] = s } removeFromInventory(t) { let e = this.globals.inventory[t]; void 0 !== e && (e.currentStackSize--, e.currentStackSize <= 0 && (this.globals.inventory[t] = void 0)) } get selectedInventoryItem() { return this.globals.inventory[this.globals.hotbar_selected_index] } } class Ft extends c { constructor(t, e) { super(t, e), this.scene = t, this.isRenderable = !0, this.controls = { start: !1, button_held: !1 }, this.width = 6, this.height = 2, this.mainContext.canvas.addEventListener("mousedown", (t => { this.onMouseDown(o.getMousePosition(this.mainContext.canvas, t)) })), this.mainContext.canvas.addEventListener("mouseup", (t => { this.onMouseUp(o.getMousePosition(this.mainContext.canvas, t)) })) } render(t) { this.renderStartButton(t) } renderStartButton(t) { e.renderSprite(t, this.assets.images.tileset_button, this.controls.button_held ? 6 : 0, 2, this.transform.position.x, this.transform.position.y, this.width, this.height) } onMouseDown(t) { t.exactX < this.transform.position.x || t.exactX > this.transform.position.x + this.width - 0 || t.exactY < this.transform.position.y || t.exactY > this.transform.position.y + this.height - 0 || (this.controls.button_held = !0) } onMouseUp(t) { this.controls.button_held && (t.exactX < this.transform.position.x || t.exactX > this.transform.position.x + this.width - 0 || t.exactY < this.transform.position.y || t.exactY > this.transform.position.y + this.height - 0 ? this.controls.button_held = !1 : (this.controls.button_held = !1, this.controls.start = !0)) } update(t) { this.updateStart() } updateStart() { this.controls.start && (this.scene.changeScene(Bt), this.controls.start = !1) } } const Pt = t.CANVAS_TILE_HEIGHT, Vt = t.CANVAS_TILE_WIDTH; class Gt extends n { constructor(t) { super(t), this.scene = t, this.height = Pt, this.width = Vt, this.backgroundLayers = [h], this.objects = [], o.setCursor(this.context.canvas, "/assets/sample/Mouse sprites/Triangle Mouse icon 1.png"), this.objects.push(new Ft(t, { renderLayer: 15, positionX: 12, positionY: 7.5 })), this.objects.push(new m(t, {})) } } class zt extends Nt { constructor(t) { super(t), this.client = t, this.changeMap(Gt) } } !function () { const t = [zt, Bt]; window.engine = new i(document.getElementById("render-area"), t, { images: { tileset_sample: "assets/16x16.png", tileset_grass: "assets/sample/Tilesets/Grass.png", tileset_hills: "assets/sample/Tilesets/Hills.png", tileset_water: "assets/sample/Tilesets/Water.png", tileset_player: "assets/sample/Characters/Basic Charakter Spritesheet.png", tileset_chicken: "assets/sample/Characters/Free Chicken Sprites.png", tileset_fence: "assets/sample/Tilesets/Fences.png", tileset_egg: "assets/sample/Characters/Egg_And_Nest.png", tileset_house: "assets/sample/Tilesets/Wooden House.png", tileset_dirt: "assets/sample/Tilesets/Tilled_Dirt.png", tileset_button: "assets/sample/UI Big Play Button.png", tileset_ui: "assets/sample/Sprite sheet for Basic Pack.png", tileset_wood_bridge: "assets/sample/Objects/Wood_Bridge.png", tileset_chest: "assets/sample/Objects/Chest.png", tileset_plants: "assets/sample/Objects/Basic_Plants.png", tileset_dialogue_box: "assets/sample/Dialouge UI/dialog box.png" }, audio: {} }, s.engineObjectList, s.engineObjectDetails, s.engineControls) }() })();